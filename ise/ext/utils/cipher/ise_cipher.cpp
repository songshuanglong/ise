/****************************************************************************\
*                                                                            *
*  ISE (Iris Server Engine) Project                                          *
*  http://github.com/haoxingeng/ise                                          *
*                                                                            *
*  Copyright 2013 HaoXinGeng (haoxingeng@gmail.com)                          *
*  All rights reserved.                                                      *
*                                                                            *
*  Licensed under the Apache License, Version 2.0 (the "License");           *
*  you may not use this file except in compliance with the License.          *
*  You may obtain a copy of the License at                                   *
*                                                                            *
*      http://www.apache.org/licenses/LICENSE-2.0                            *
*                                                                            *
*  Unless required by applicable law or agreed to in writing, software       *
*  distributed under the License is distributed on an "AS IS" BASIS,         *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *
*  See the License for the specific language governing permissions and       *
*  limitations under the License.                                            *
*                                                                            *
\****************************************************************************/

///////////////////////////////////////////////////////////////////////////////
// 文件名称: ise_cipher.cpp
// 功能描述: 常用数据编码解码算法
///////////////////////////////////////////////////////////////////////////////

#include "ise/ext/utils/cipher/ise_cipher.h"
#include "ise/main/ise_sys_utils.h"

namespace ise
{

namespace utils
{

///////////////////////////////////////////////////////////////////////////////
// Error Messages

const char * const S_INVALID_STRING_FORMAT  = "Input is not an valid %s format";
const char * const S_HASH_NOT_INITIALIZED   = "Hash must be initialized";
const char * const S_HASHING_OVERFLOW_ERROR = "Hash function have to many bits processed";
const char * const S_INVALID_FORMAT_TYPE    = "Invalid format type (%d)";
const char * const S_INVALID_HASH_TYPE      = "Invalid hash type (%d)";
const char * const S_INVALID_CIPHER_TYPE    = "Invalid cipher type (%d)";
const char * const S_ALREADY_PADDED         = "Cipher has already been padded, cannot process message";
const char * const S_INVALID_STATE          = "Cipher is not in valid state for this action";
const char * const S_INVALID_MESSAGE_LENGTH = "Message length for %s must be a multiple of %d bytes";
const char * const S_KEY_MATERIAL_TOO_LARGE = "Keymaterial is too large for use (Security Issue)";
const char * const S_IVMATERIAL_TOO_LARGE   = "Initvector is too large for use (Security Issue)";

///////////////////////////////////////////////////////////////////////////////
// Constant Defines

const int STREAM_BUF_SIZE = 8192;

///////////////////////////////////////////////////////////////////////////////
// Constant Defines

const DWORD BLOWFISH_DATA[4][256] = {{
    0xD1310BA6,0x98DFB5AC,0x2FFD72DB,0xD01ADFB7,0xB8E1AFED,0x6A267E96,0xBA7C9045,0xF12C7F99,
    0x24A19947,0xB3916CF7,0x0801F2E2,0x858EFC16,0x636920D8,0x71574E69,0xA458FEA3,0xF4933D7E,
    0x0D95748F,0x728EB658,0x718BCD58,0x82154AEE,0x7B54A41D,0xC25A59B5,0x9C30D539,0x2AF26013,
    0xC5D1B023,0x286085F0,0xCA417918,0xB8DB38EF,0x8E79DCB0,0x603A180E,0x6C9E0E8B,0xB01E8A3E,
    0xD71577C1,0xBD314B27,0x78AF2FDA,0x55605C60,0xE65525F3,0xAA55AB94,0x57489862,0x63E81440,
    0x55CA396A,0x2AAB10B6,0xB4CC5C34,0x1141E8CE,0xA15486AF,0x7C72E993,0xB3EE1411,0x636FBC2A,
    0x2BA9C55D,0x741831F6,0xCE5C3E16,0x9B87931E,0xAFD6BA33,0x6C24CF5C,0x7A325381,0x28958677,
    0x3B8F4898,0x6B4BB9AF,0xC4BFE81B,0x66282193,0x61D809CC,0xFB21A991,0x487CAC60,0x5DEC8032,
    0xEF845D5D,0xE98575B1,0xDC262302,0xEB651B88,0x23893E81,0xD396ACC5,0x0F6D6FF3,0x83F44239,
    0x2E0B4482,0xA4842004,0x69C8F04A,0x9E1F9B5E,0x21C66842,0xF6E96C9A,0x670C9C61,0xABD388F0,
    0x6A51A0D2,0xD8542F68,0x960FA728,0xAB5133A3,0x6EEF0B6C,0x137A3BE4,0xBA3BF050,0x7EFB2A98,
    0xA1F1651D,0x39AF0176,0x66CA593E,0x82430E88,0x8CEE8619,0x456F9FB4,0x7D84A5C3,0x3B8B5EBE,
    0xE06F75D8,0x85C12073,0x401A449F,0x56C16AA6,0x4ED3AA62,0x363F7706,0x1BFEDF72,0x429B023D,
    0x37D0D724,0xD00A1248,0xDB0FEAD3,0x49F1C09B,0x075372C9,0x80991B7B,0x25D479D8,0xF6E8DEF7,
    0xE3FE501A,0xB6794C3B,0x976CE0BD,0x04C006BA,0xC1A94FB6,0x409F60C4,0x5E5C9EC2,0x196A2463,
    0x68FB6FAF,0x3E6C53B5,0x1339B2EB,0x3B52EC6F,0x6DFC511F,0x9B30952C,0xCC814544,0xAF5EBD09,
    0xBEE3D004,0xDE334AFD,0x660F2807,0x192E4BB3,0xC0CBA857,0x45C8740F,0xD20B5F39,0xB9D3FBDB,
    0x5579C0BD,0x1A60320A,0xD6A100C6,0x402C7279,0x679F25FE,0xFB1FA3CC,0x8EA5E9F8,0xDB3222F8,
    0x3C7516DF,0xFD616B15,0x2F501EC8,0xAD0552AB,0x323DB5FA,0xFD238760,0x53317B48,0x3E00DF82,
    0x9E5C57BB,0xCA6F8CA0,0x1A87562E,0xDF1769DB,0xD542A8F6,0x287EFFC3,0xAC6732C6,0x8C4F5573,
    0x695B27B0,0xBBCA58C8,0xE1FFA35D,0xB8F011A0,0x10FA3D98,0xFD2183B8,0x4AFCB56C,0x2DD1D35B,
    0x9A53E479,0xB6F84565,0xD28E49BC,0x4BFB9790,0xE1DDF2DA,0xA4CB7E33,0x62FB1341,0xCEE4C6E8,
    0xEF20CADA,0x36774C01,0xD07E9EFE,0x2BF11FB4,0x95DBDA4D,0xAE909198,0xEAAD8E71,0x6B93D5A0,
    0xD08ED1D0,0xAFC725E0,0x8E3C5B2F,0x8E7594B7,0x8FF6E2FB,0xF2122B64,0x8888B812,0x900DF01C,
    0x4FAD5EA0,0x688FC31C,0xD1CFF191,0xB3A8C1AD,0x2F2F2218,0xBE0E1777,0xEA752DFE,0x8B021FA1,
    0xE5A0CC0F,0xB56F74E8,0x18ACF3D6,0xCE89E299,0xB4A84FE0,0xFD13E0B7,0x7CC43B81,0xD2ADA8D9,
    0x165FA266,0x80957705,0x93CC7314,0x211A1477,0xE6AD2065,0x77B5FA86,0xC75442F5,0xFB9D35CF,
    0xEBCDAF0C,0x7B3E89A0,0xD6411BD3,0xAE1E7E49,0x00250E2D,0x2071B35E,0x226800BB,0x57B8E0AF,
    0x2464369B,0xF009B91E,0x5563911D,0x59DFA6AA,0x78C14389,0xD95A537F,0x207D5BA2,0x02E5B9C5,
    0x83260376,0x6295CFA9,0x11C81968,0x4E734A41,0xB3472DCA,0x7B14A94A,0x1B510052,0x9A532915,
    0xD60F573F,0xBC9BC6E4,0x2B60A476,0x81E67400,0x08BA6FB5,0x571BE91F,0xF296EC6B,0x2A0DD915,
    0xB6636521,0xE7B9F9B6,0xFF34052E,0xC5855664,0x53B02D5D,0xA99F8FA1,0x08BA4799,0x6E85076A
    },{
    0x4B7A70E9,0xB5B32944,0xDB75092E,0xC4192623,0xAD6EA6B0,0x49A7DF7D,0x9CEE60B8,0x8FEDB266,
    0xECAA8C71,0x699A17FF,0x5664526C,0xC2B19EE1,0x193602A5,0x75094C29,0xA0591340,0xE4183A3E,
    0x3F54989A,0x5B429D65,0x6B8FE4D6,0x99F73FD6,0xA1D29C07,0xEFE830F5,0x4D2D38E6,0xF0255DC1,
    0x4CDD2086,0x8470EB26,0x6382E9C6,0x021ECC5E,0x09686B3F,0x3EBAEFC9,0x3C971814,0x6B6A70A1,
    0x687F3584,0x52A0E286,0xB79C5305,0xAA500737,0x3E07841C,0x7FDEAE5C,0x8E7D44EC,0x5716F2B8,
    0xB03ADA37,0xF0500C0D,0xF01C1F04,0x0200B3FF,0xAE0CF51A,0x3CB574B2,0x25837A58,0xDC0921BD,
    0xD19113F9,0x7CA92FF6,0x94324773,0x22F54701,0x3AE5E581,0x37C2DADC,0xC8B57634,0x9AF3DDA7,
    0xA9446146,0x0FD0030E,0xECC8C73E,0xA4751E41,0xE238CD99,0x3BEA0E2F,0x3280BBA1,0x183EB331,
    0x4E548B38,0x4F6DB908,0x6F420D03,0xF60A04BF,0x2CB81290,0x24977C79,0x5679B072,0xBCAF89AF,
    0xDE9A771F,0xD9930810,0xB38BAE12,0xDCCF3F2E,0x5512721F,0x2E6B7124,0x501ADDE6,0x9F84CD87,
    0x7A584718,0x7408DA17,0xBC9F9ABC,0xE94B7D8C,0xEC7AEC3A,0xDB851DFA,0x63094366,0xC464C3D2,
    0xEF1C1847,0x3215D908,0xDD433B37,0x24C2BA16,0x12A14D43,0x2A65C451,0x50940002,0x133AE4DD,
    0x71DFF89E,0x10314E55,0x81AC77D6,0x5F11199B,0x043556F1,0xD7A3C76B,0x3C11183B,0x5924A509,
    0xF28FE6ED,0x97F1FBFA,0x9EBABF2C,0x1E153C6E,0x86E34570,0xEAE96FB1,0x860E5E0A,0x5A3E2AB3,
    0x771FE71C,0x4E3D06FA,0x2965DCB9,0x99E71D0F,0x803E89D6,0x5266C825,0x2E4CC978,0x9C10B36A,
    0xC6150EBA,0x94E2EA78,0xA5FC3C53,0x1E0A2DF4,0xF2F74EA7,0x361D2B3D,0x1939260F,0x19C27960,
    0x5223A708,0xF71312B6,0xEBADFE6E,0xEAC31F66,0xE3BC4595,0xA67BC883,0xB17F37D1,0x018CFF28,
    0xC332DDEF,0xBE6C5AA5,0x65582185,0x68AB9802,0xEECEA50F,0xDB2F953B,0x2AEF7DAD,0x5B6E2F84,
    0x1521B628,0x29076170,0xECDD4775,0x619F1510,0x13CCA830,0xEB61BD96,0x0334FE1E,0xAA0363CF,
    0xB5735C90,0x4C70A239,0xD59E9E0B,0xCBAADE14,0xEECC86BC,0x60622CA7,0x9CAB5CAB,0xB2F3846E,
    0x648B1EAF,0x19BDF0CA,0xA02369B9,0x655ABB50,0x40685A32,0x3C2AB4B3,0x319EE9D5,0xC021B8F7,
    0x9B540B19,0x875FA099,0x95F7997E,0x623D7DA8,0xF837889A,0x97E32D77,0x11ED935F,0x16681281,
    0x0E358829,0xC7E61FD6,0x96DEDFA1,0x7858BA99,0x57F584A5,0x1B227263,0x9B83C3FF,0x1AC24696,
    0xCDB30AEB,0x532E3054,0x8FD948E4,0x6DBC3128,0x58EBF2EF,0x34C6FFEA,0xFE28ED61,0xEE7C3C73,
    0x5D4A14D9,0xE864B7E3,0x42105D14,0x203E13E0,0x45EEE2B6,0xA3AAABEA,0xDB6C4F15,0xFACB4FD0,
    0xC742F442,0xEF6ABBB5,0x654F3B1D,0x41CD2105,0xD81E799E,0x86854DC7,0xE44B476A,0x3D816250,
    0xCF62A1F2,0x5B8D2646,0xFC8883A0,0xC1C7B6A3,0x7F1524C3,0x69CB7492,0x47848A0B,0x5692B285,
    0x095BBF00,0xAD19489D,0x1462B174,0x23820E00,0x58428D2A,0x0C55F5EA,0x1DADF43E,0x233F7061,
    0x3372F092,0x8D937E41,0xD65FECF1,0x6C223BDB,0x7CDE3759,0xCBEE7460,0x4085F2A7,0xCE77326E,
    0xA6078084,0x19F8509E,0xE8EFD855,0x61D99735,0xA969A7AA,0xC50C06C2,0x5A04ABFC,0x800BCADC,
    0x9E447A2E,0xC3453484,0xFDD56705,0x0E1E9EC9,0xDB73DBD3,0x105588CD,0x675FDA79,0xE3674340,
    0xC5C43465,0x713E38D8,0x3D28F89E,0xF16DFF20,0x153E21E7,0x8FB03D4A,0xE6E39F2B,0xDB83ADF7
    },{
    0xE93D5A68,0x948140F7,0xF64C261C,0x94692934,0x411520F7,0x7602D4F7,0xBCF46B2E,0xD4A20068,
    0xD4082471,0x3320F46A,0x43B7D4B7,0x500061AF,0x1E39F62E,0x97244546,0x14214F74,0xBF8B8840,
    0x4D95FC1D,0x96B591AF,0x70F4DDD3,0x66A02F45,0xBFBC09EC,0x03BD9785,0x7FAC6DD0,0x31CB8504,
    0x96EB27B3,0x55FD3941,0xDA2547E6,0xABCA0A9A,0x28507825,0x530429F4,0x0A2C86DA,0xE9B66DFB,
    0x68DC1462,0xD7486900,0x680EC0A4,0x27A18DEE,0x4F3FFEA2,0xE887AD8C,0xB58CE006,0x7AF4D6B6,
    0xAACE1E7C,0xD3375FEC,0xCE78A399,0x406B2A42,0x20FE9E35,0xD9F385B9,0xEE39D7AB,0x3B124E8B,
    0x1DC9FAF7,0x4B6D1856,0x26A36631,0xEAE397B2,0x3A6EFA74,0xDD5B4332,0x6841E7F7,0xCA7820FB,
    0xFB0AF54E,0xD8FEB397,0x454056AC,0xBA489527,0x55533A3A,0x20838D87,0xFE6BA9B7,0xD096954B,
    0x55A867BC,0xA1159A58,0xCCA92963,0x99E1DB33,0xA62A4A56,0x3F3125F9,0x5EF47E1C,0x9029317C,
    0xFDF8E802,0x04272F70,0x80BB155C,0x05282CE3,0x95C11548,0xE4C66D22,0x48C1133F,0xC70F86DC,
    0x07F9C9EE,0x41041F0F,0x404779A4,0x5D886E17,0x325F51EB,0xD59BC0D1,0xF2BCC18F,0x41113564,
    0x257B7834,0x602A9C60,0xDFF8E8A3,0x1F636C1B,0x0E12B4C2,0x02E1329E,0xAF664FD1,0xCAD18115,
    0x6B2395E0,0x333E92E1,0x3B240B62,0xEEBEB922,0x85B2A20E,0xE6BA0D99,0xDE720C8C,0x2DA2F728,
    0xD0127845,0x95B794FD,0x647D0862,0xE7CCF5F0,0x5449A36F,0x877D48FA,0xC39DFD27,0xF33E8D1E,
    0x0A476341,0x992EFF74,0x3A6F6EAB,0xF4F8FD37,0xA812DC60,0xA1EBDDF8,0x991BE14C,0xDB6E6B0D,
    0xC67B5510,0x6D672C37,0x2765D43B,0xDCD0E804,0xF1290DC7,0xCC00FFA3,0xB5390F92,0x690FED0B,
    0x667B9FFB,0xCEDB7D9C,0xA091CF0B,0xD9155EA3,0xBB132F88,0x515BAD24,0x7B9479BF,0x763BD6EB,
    0x37392EB3,0xCC115979,0x8026E297,0xF42E312D,0x6842ADA7,0xC66A2B3B,0x12754CCC,0x782EF11C,
    0x6A124237,0xB79251E7,0x06A1BBE6,0x4BFB6350,0x1A6B1018,0x11CAEDFA,0x3D25BDD8,0xE2E1C3C9,
    0x44421659,0x0A121386,0xD90CEC6E,0xD5ABEA2A,0x64AF674E,0xDA86A85F,0xBEBFE988,0x64E4C3FE,
    0x9DBC8057,0xF0F7C086,0x60787BF8,0x6003604D,0xD1FD8346,0xF6381FB0,0x7745AE04,0xD736FCCC,
    0x83426B33,0xF01EAB71,0xB0804187,0x3C005E5F,0x77A057BE,0xBDE8AE24,0x55464299,0xBF582E61,
    0x4E58F48F,0xF2DDFDA2,0xF474EF38,0x8789BDC2,0x5366F9C3,0xC8B38E74,0xB475F255,0x46FCD9B9,
    0x7AEB2661,0x8B1DDF84,0x846A0E79,0x915F95E2,0x466E598E,0x20B45770,0x8CD55591,0xC902DE4C,
    0xB90BACE1,0xBB8205D0,0x11A86248,0x7574A99E,0xB77F19B6,0xE0A9DC09,0x662D09A1,0xC4324633,
    0xE85A1F02,0x09F0BE8C,0x4A99A025,0x1D6EFE10,0x1AB93D1D,0x0BA5A4DF,0xA186F20F,0x2868F169,
    0xDCB7DA83,0x573906FE,0xA1E2CE9B,0x4FCD7F52,0x50115E01,0xA70683FA,0xA002B5C4,0x0DE6D027,
    0x9AF88C27,0x773F8641,0xC3604C06,0x61A806B5,0xF0177A28,0xC0F586E0,0x006058AA,0x30DC7D62,
    0x11E69ED7,0x2338EA63,0x53C2DD94,0xC2C21634,0xBBCBEE56,0x90BCB6DE,0xEBFC7DA1,0xCE591D76,
    0x6F05E409,0x4B7C0188,0x39720A3D,0x7C927C24,0x86E3725F,0x724D9DB9,0x1AC15BB4,0xD39EB8FC,
    0xED545578,0x08FCA5B5,0xD83D7CD3,0x4DAD0FC4,0x1E50EF5E,0xB161E6F8,0xA28514D9,0x6C51133C,
    0x6FD5C7E7,0x56E14EC4,0x362ABFCE,0xDDC6C837,0xD79A3234,0x92638212,0x670EFA8E,0x406000E0
    },{
    0x3A39CE37,0xD3FAF5CF,0xABC27737,0x5AC52D1B,0x5CB0679E,0x4FA33742,0xD3822740,0x99BC9BBE,
    0xD5118E9D,0xBF0F7315,0xD62D1C7E,0xC700C47B,0xB78C1B6B,0x21A19045,0xB26EB1BE,0x6A366EB4,
    0x5748AB2F,0xBC946E79,0xC6A376D2,0x6549C2C8,0x530FF8EE,0x468DDE7D,0xD5730A1D,0x4CD04DC6,
    0x2939BBDB,0xA9BA4650,0xAC9526E8,0xBE5EE304,0xA1FAD5F0,0x6A2D519A,0x63EF8CE2,0x9A86EE22,
    0xC089C2B8,0x43242EF6,0xA51E03AA,0x9CF2D0A4,0x83C061BA,0x9BE96A4D,0x8FE51550,0xBA645BD6,
    0x2826A2F9,0xA73A3AE1,0x4BA99586,0xEF5562E9,0xC72FEFD3,0xF752F7DA,0x3F046F69,0x77FA0A59,
    0x80E4A915,0x87B08601,0x9B09E6AD,0x3B3EE593,0xE990FD5A,0x9E34D797,0x2CF0B7D9,0x022B8B51,
    0x96D5AC3A,0x017DA67D,0xD1CF3ED6,0x7C7D2D28,0x1F9F25CF,0xADF2B89B,0x5AD6B472,0x5A88F54C,
    0xE029AC71,0xE019A5E6,0x47B0ACFD,0xED93FA9B,0xE8D3C48D,0x283B57CC,0xF8D56629,0x79132E28,
    0x785F0191,0xED756055,0xF7960E44,0xE3D35E8C,0x15056DD4,0x88F46DBA,0x03A16125,0x0564F0BD,
    0xC3EB9E15,0x3C9057A2,0x97271AEC,0xA93A072A,0x1B3F6D9B,0x1E6321F5,0xF59C66FB,0x26DCF319,
    0x7533D928,0xB155FDF5,0x03563482,0x8ABA3CBB,0x28517711,0xC20AD9F8,0xABCC5167,0xCCAD925F,
    0x4DE81751,0x3830DC8E,0x379D5862,0x9320F991,0xEA7A90C2,0xFB3E7BCE,0x5121CE64,0x774FBE32,
    0xA8B6E37E,0xC3293D46,0x48DE5369,0x6413E680,0xA2AE0810,0xDD6DB224,0x69852DFD,0x09072166,
    0xB39A460A,0x6445C0DD,0x586CDECF,0x1C20C8AE,0x5BBEF7DD,0x1B588D40,0xCCD2017F,0x6BB4E3BB,
    0xDDA26A7E,0x3A59FF45,0x3E350A44,0xBCB4CDD5,0x72EACEA8,0xFA6484BB,0x8D6612AE,0xBF3C6F47,
    0xD29BE463,0x542F5D9E,0xAEC2771B,0xF64E6370,0x740E0D8D,0xE75B1357,0xF8721671,0xAF537D5D,
    0x4040CB08,0x4EB4E2CC,0x34D2466A,0x0115AF84,0xE1B00428,0x95983A1D,0x06B89FB4,0xCE6EA048,
    0x6F3F3B82,0x3520AB82,0x011A1D4B,0x277227F8,0x611560B1,0xE7933FDC,0xBB3A792B,0x344525BD,
    0xA08839E1,0x51CE794B,0x2F32C9B7,0xA01FBAC9,0xE01CC87E,0xBCC7D1F6,0xCF0111C3,0xA1E8AAC7,
    0x1A908749,0xD44FBD9A,0xD0DADECB,0xD50ADA38,0x0339C32A,0xC6913667,0x8DF9317C,0xE0B12B4F,
    0xF79E59B7,0x43F5BB3A,0xF2D519FF,0x27D9459C,0xBF97222C,0x15E6FC2A,0x0F91FC71,0x9B941525,
    0xFAE59361,0xCEB69CEB,0xC2A86459,0x12BAA8D1,0xB6C1075E,0xE3056A0C,0x10D25065,0xCB03A442,
    0xE0EC6E0E,0x1698DB3B,0x4C98A0BE,0x3278E964,0x9F1F9532,0xE0D392DF,0xD3A0342B,0x8971F21E,
    0x1B0A7441,0x4BA3348C,0xC5BE7120,0xC37632D8,0xDF359F8D,0x9B992F2E,0xE60B6F47,0x0FE3F11D,
    0xE54CDA54,0x1EDAD891,0xCE6279CF,0xCD3E7E6F,0x1618B166,0xFD2C1D05,0x848FD2C5,0xF6FB2299,
    0xF523F357,0xA6327623,0x93A83531,0x56CCCD02,0xACF08162,0x5A75EBB5,0x6E163697,0x88D273CC,
    0xDE966292,0x81B949D0,0x4C50901B,0x71C65614,0xE6C6C7BD,0x327A140A,0x45E1D006,0xC3F27B9A,
    0xC9AA53FD,0x62A80F00,0xBB25BFE2,0x35BDD2F6,0x71126905,0xB2040222,0xB6CBCF7C,0xCD769C2B,
    0x53113EC0,0x1640E3D3,0x38ABBD60,0x2547ADF0,0xBA38209C,0xF746CE76,0x77AFA1C5,0x20756060,
    0x85CBFE4E,0x8AE88DD8,0x7AAAF9B0,0x4CF9AA7E,0x1948C25C,0x02FB8A8C,0x01C36AE4,0xD6EBE1F9,
    0x90D4F869,0xA65CDEA0,0x3F09252D,0xC208E69F,0xB74E6132,0xCE77E25B,0x578FDFE3,0x3AC372E6
    }};

const DWORD BLOWFISH_KEY[18] = {
    0x243F6A88,0x85A308D3,0x13198A2E,0x03707344,0xA4093822,0x299F31D0,
    0x082EFA98,0xEC4E6C89,0x452821E6,0x38D01377,0xBE5466CF,0x34E90C6C,
    0xC0AC29B7,0xC97C50DD,0x3F84D5B5,0xB5470917,0x9216D5D9,0x8979FB1B
    };

const BYTE DES_PC1[56] = {
    56, 48, 40, 32, 24, 16,  8,  0, 57, 49, 41, 33, 25, 17,
     9,  1, 58, 50, 42, 34, 26,	18, 10,  2, 59, 51, 43, 35,
    62, 54, 46, 38, 30, 22, 14,	 6, 61, 53, 45, 37, 29, 21,
    13,  5, 60, 52, 44, 36, 28,	20, 12,  4, 27, 19, 11,  3
    };

const BYTE DES_PC2[48] = {
    13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,
    22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,
    40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
    43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31
    };

const DWORD DES_DATA[8][64] = {{
    0x00200000,0x04200002,0x04000802,0x00000000,0x00000800,0x04000802,0x00200802,0x04200800,
    0x04200802,0x00200000,0x00000000,0x04000002,0x00000002,0x04000000,0x04200002,0x00000802,
    0x04000800,0x00200802,0x00200002,0x04000800,0x04000002,0x04200000,0x04200800,0x00200002,
    0x04200000,0x00000800,0x00000802,0x04200802,0x00200800,0x00000002,0x04000000,0x00200800,
    0x04000000,0x00200800,0x00200000,0x04000802,0x04000802,0x04200002,0x04200002,0x00000002,
    0x00200002,0x04000000,0x04000800,0x00200000,0x04200800,0x00000802,0x00200802,0x04200800,
    0x00000802,0x04000002,0x04200802,0x04200000,0x00200800,0x00000000,0x00000002,0x04200802,
    0x00000000,0x00200802,0x04200000,0x00000800,0x04000002,0x04000800,0x00000800,0x00200002
    },{
    0x00000100,0x02080100,0x02080000,0x42000100,0x00080000,0x00000100,0x40000000,0x02080000,
    0x40080100,0x00080000,0x02000100,0x40080100,0x42000100,0x42080000,0x00080100,0x40000000,
    0x02000000,0x40080000,0x40080000,0x00000000,0x40000100,0x42080100,0x42080100,0x02000100,
    0x42080000,0x40000100,0x00000000,0x42000000,0x02080100,0x02000000,0x42000000,0x00080100,
    0x00080000,0x42000100,0x00000100,0x02000000,0x40000000,0x02080000,0x42000100,0x40080100,
    0x02000100,0x40000000,0x42080000,0x02080100,0x40080100,0x00000100,0x02000000,0x42080000,
    0x42080100,0x00080100,0x42000000,0x42080100,0x02080000,0x00000000,0x40080000,0x42000000,
    0x00080100,0x02000100,0x40000100,0x00080000,0x00000000,0x40080000,0x02080100,0x40000100
    },{
    0x00000208,0x08020200,0x00000000,0x08020008,0x08000200,0x00000000,0x00020208,0x08000200,
    0x00020008,0x08000008,0x08000008,0x00020000,0x08020208,0x00020008,0x08020000,0x00000208,
    0x08000000,0x00000008,0x08020200,0x00000200,0x00020200,0x08020000,0x08020008,0x00020208,
    0x08000208,0x00020200,0x00020000,0x08000208,0x00000008,0x08020208,0x00000200,0x08000000,
    0x08020200,0x08000000,0x00020008,0x00000208,0x00020000,0x08020200,0x08000200,0x00000000,
    0x00000200,0x00020008,0x08020208,0x08000200,0x08000008,0x00000200,0x00000000,0x08020008,
    0x08000208,0x00020000,0x08000000,0x08020208,0x00000008,0x00020208,0x00020200,0x08000008,
    0x08020000,0x08000208,0x00000208,0x08020000,0x00020208,0x00000008,0x08020008,0x00020200
    },{
    0x01010400,0x00000000,0x00010000,0x01010404,0x01010004,0x00010404,0x00000004,0x00010000,
    0x00000400,0x01010400,0x01010404,0x00000400,0x01000404,0x01010004,0x01000000,0x00000004,
    0x00000404,0x01000400,0x01000400,0x00010400,0x00010400,0x01010000,0x01010000,0x01000404,
    0x00010004,0x01000004,0x01000004,0x00010004,0x00000000,0x00000404,0x00010404,0x01000000,
    0x00010000,0x01010404,0x00000004,0x01010000,0x01010400,0x01000000,0x01000000,0x00000400,
    0x01010004,0x00010000,0x00010400,0x01000004,0x00000400,0x00000004,0x01000404,0x00010404,
    0x01010404,0x00010004,0x01010000,0x01000404,0x01000004,0x00000404,0x00010404,0x01010400,
    0x00000404,0x01000400,0x01000400,0x00000000,0x00010004,0x00010400,0x00000000,0x01010004
    },{
    0x10001040,0x00001000,0x00040000,0x10041040,0x10000000,0x10001040,0x00000040,0x10000000,
    0x00040040,0x10040000,0x10041040,0x00041000,0x10041000,0x00041040,0x00001000,0x00000040,
    0x10040000,0x10000040,0x10001000,0x00001040,0x00041000,0x00040040,0x10040040,0x10041000,
    0x00001040,0x00000000,0x00000000,0x10040040,0x10000040,0x10001000,0x00041040,0x00040000,
    0x00041040,0x00040000,0x10041000,0x00001000,0x00000040,0x10040040,0x00001000,0x00041040,
    0x10001000,0x00000040,0x10000040,0x10040000,0x10040040,0x10000000,0x00040000,0x10001040,
    0x00000000,0x10041040,0x00040040,0x10000040,0x10040000,0x10001000,0x10001040,0x00000000,
    0x10041040,0x00041000,0x00041000,0x00001040,0x00001040,0x00040040,0x10000000,0x10041000
    },{
    0x20000010,0x20400000,0x00004000,0x20404010,0x20400000,0x00000010,0x20404010,0x00400000,
    0x20004000,0x00404010,0x00400000,0x20000010,0x00400010,0x20004000,0x20000000,0x00004010,
    0x00000000,0x00400010,0x20004010,0x00004000,0x00404000,0x20004010,0x00000010,0x20400010,
    0x20400010,0x00000000,0x00404010,0x20404000,0x00004010,0x00404000,0x20404000,0x20000000,
    0x20004000,0x00000010,0x20400010,0x00404000,0x20404010,0x00400000,0x00004010,0x20000010,
    0x00400000,0x20004000,0x20000000,0x00004010,0x20000010,0x20404010,0x00404000,0x20400000,
    0x00404010,0x20404000,0x00000000,0x20400010,0x00000010,0x00004000,0x20400000,0x00404010,
    0x00004000,0x00400010,0x20004010,0x00000000,0x20404000,0x20000000,0x00400010,0x20004010
    },{
    0x00802001,0x00002081,0x00002081,0x00000080,0x00802080,0x00800081,0x00800001,0x00002001,
    0x00000000,0x00802000,0x00802000,0x00802081,0x00000081,0x00000000,0x00800080,0x00800001,
    0x00000001,0x00002000,0x00800000,0x00802001,0x00000080,0x00800000,0x00002001,0x00002080,
    0x00800081,0x00000001,0x00002080,0x00800080,0x00002000,0x00802080,0x00802081,0x00000081,
    0x00800080,0x00800001,0x00802000,0x00802081,0x00000081,0x00000000,0x00000000,0x00802000,
    0x00002080,0x00800080,0x00800081,0x00000001,0x00802001,0x00002081,0x00002081,0x00000080,
    0x00802081,0x00000081,0x00000001,0x00002000,0x00800001,0x00002001,0x00802080,0x00800081,
    0x00002001,0x00002080,0x00800000,0x00802001,0x00000080,0x00800000,0x00002000,0x00802080
    },{
    0x80108020,0x80008000,0x00008000,0x00108020,0x00100000,0x00000020,0x80100020,0x80008020,
    0x80000020,0x80108020,0x80108000,0x80000000,0x80008000,0x00100000,0x00000020,0x80100020,
    0x00108000,0x00100020,0x80008020,0x00000000,0x80000000,0x00008000,0x00108020,0x80100000,
    0x00100020,0x80000020,0x00000000,0x00108000,0x00008020,0x80108000,0x80100000,0x00008020,
    0x00000000,0x00108020,0x80100020,0x00100000,0x80008020,0x80100000,0x80108000,0x00008000,
    0x80100000,0x80008000,0x00000020,0x80108020,0x00108020,0x00000020,0x00008000,0x80000000,
    0x00008020,0x80108000,0x00100000,0x80000020,0x00100020,0x80008020,0x80000020,0x00100020,
    0x00108000,0x00000000,0x80008000,0x00008020,0x80000000,0x80100020,0x80108020,0x00108000
    }};

const DWORD GOST_DATA[4][256] = {{
    0x00072000,0x00075000,0x00074800,0x00071000,0x00076800,0x00074000,0x00070000,0x00077000,
    0x00073000,0x00075800,0x00070800,0x00076000,0x00073800,0x00077800,0x00072800,0x00071800,
    0x0005A000,0x0005D000,0x0005C800,0x00059000,0x0005E800,0x0005C000,0x00058000,0x0005F000,
    0x0005B000,0x0005D800,0x00058800,0x0005E000,0x0005B800,0x0005F800,0x0005A800,0x00059800,
    0x00022000,0x00025000,0x00024800,0x00021000,0x00026800,0x00024000,0x00020000,0x00027000,
    0x00023000,0x00025800,0x00020800,0x00026000,0x00023800,0x00027800,0x00022800,0x00021800,
    0x00062000,0x00065000,0x00064800,0x00061000,0x00066800,0x00064000,0x00060000,0x00067000,
    0x00063000,0x00065800,0x00060800,0x00066000,0x00063800,0x00067800,0x00062800,0x00061800,
    0x00032000,0x00035000,0x00034800,0x00031000,0x00036800,0x00034000,0x00030000,0x00037000,
    0x00033000,0x00035800,0x00030800,0x00036000,0x00033800,0x00037800,0x00032800,0x00031800,
    0x0006A000,0x0006D000,0x0006C800,0x00069000,0x0006E800,0x0006C000,0x00068000,0x0006F000,
    0x0006B000,0x0006D800,0x00068800,0x0006E000,0x0006B800,0x0006F800,0x0006A800,0x00069800,
    0x0007A000,0x0007D000,0x0007C800,0x00079000,0x0007E800,0x0007C000,0x00078000,0x0007F000,
    0x0007B000,0x0007D800,0x00078800,0x0007E000,0x0007B800,0x0007F800,0x0007A800,0x00079800,
    0x00052000,0x00055000,0x00054800,0x00051000,0x00056800,0x00054000,0x00050000,0x00057000,
    0x00053000,0x00055800,0x00050800,0x00056000,0x00053800,0x00057800,0x00052800,0x00051800,
    0x00012000,0x00015000,0x00014800,0x00011000,0x00016800,0x00014000,0x00010000,0x00017000,
    0x00013000,0x00015800,0x00010800,0x00016000,0x00013800,0x00017800,0x00012800,0x00011800,
    0x0001A000,0x0001D000,0x0001C800,0x00019000,0x0001E800,0x0001C000,0x00018000,0x0001F000,
    0x0001B000,0x0001D800,0x00018800,0x0001E000,0x0001B800,0x0001F800,0x0001A800,0x00019800,
    0x00042000,0x00045000,0x00044800,0x00041000,0x00046800,0x00044000,0x00040000,0x00047000,
    0x00043000,0x00045800,0x00040800,0x00046000,0x00043800,0x00047800,0x00042800,0x00041800,
    0x0000A000,0x0000D000,0x0000C800,0x00009000,0x0000E800,0x0000C000,0x00008000,0x0000F000,
    0x0000B000,0x0000D800,0x00008800,0x0000E000,0x0000B800,0x0000F800,0x0000A800,0x00009800,
    0x00002000,0x00005000,0x00004800,0x00001000,0x00006800,0x00004000,0x00000000,0x00007000,
    0x00003000,0x00005800,0x00000800,0x00006000,0x00003800,0x00007800,0x00002800,0x00001800,
    0x0003A000,0x0003D000,0x0003C800,0x00039000,0x0003E800,0x0003C000,0x00038000,0x0003F000,
    0x0003B000,0x0003D800,0x00038800,0x0003E000,0x0003B800,0x0003F800,0x0003A800,0x00039800,
    0x0002A000,0x0002D000,0x0002C800,0x00029000,0x0002E800,0x0002C000,0x00028000,0x0002F000,
    0x0002B000,0x0002D800,0x00028800,0x0002E000,0x0002B800,0x0002F800,0x0002A800,0x00029800,
    0x0004A000,0x0004D000,0x0004C800,0x00049000,0x0004E800,0x0004C000,0x00048000,0x0004F000,
    0x0004B000,0x0004D800,0x00048800,0x0004E000,0x0004B800,0x0004F800,0x0004A800,0x00049800
    },{
    0x03A80000,0x03C00000,0x03880000,0x03E80000,0x03D00000,0x03980000,0x03A00000,0x03900000,
    0x03F00000,0x03F80000,0x03E00000,0x03B80000,0x03B00000,0x03800000,0x03C80000,0x03D80000,
    0x06A80000,0x06C00000,0x06880000,0x06E80000,0x06D00000,0x06980000,0x06A00000,0x06900000,
    0x06F00000,0x06F80000,0x06E00000,0x06B80000,0x06B00000,0x06800000,0x06C80000,0x06D80000,
    0x05280000,0x05400000,0x05080000,0x05680000,0x05500000,0x05180000,0x05200000,0x05100000,
    0x05700000,0x05780000,0x05600000,0x05380000,0x05300000,0x05000000,0x05480000,0x05580000,
    0x00A80000,0x00C00000,0x00880000,0x00E80000,0x00D00000,0x00980000,0x00A00000,0x00900000,
    0x00F00000,0x00F80000,0x00E00000,0x00B80000,0x00B00000,0x00800000,0x00C80000,0x00D80000,
    0x00280000,0x00400000,0x00080000,0x00680000,0x00500000,0x00180000,0x00200000,0x00100000,
    0x00700000,0x00780000,0x00600000,0x00380000,0x00300000,0x00000000,0x00480000,0x00580000,
    0x04280000,0x04400000,0x04080000,0x04680000,0x04500000,0x04180000,0x04200000,0x04100000,
    0x04700000,0x04780000,0x04600000,0x04380000,0x04300000,0x04000000,0x04480000,0x04580000,
    0x04A80000,0x04C00000,0x04880000,0x04E80000,0x04D00000,0x04980000,0x04A00000,0x04900000,
    0x04F00000,0x04F80000,0x04E00000,0x04B80000,0x04B00000,0x04800000,0x04C80000,0x04D80000,
    0x07A80000,0x07C00000,0x07880000,0x07E80000,0x07D00000,0x07980000,0x07A00000,0x07900000,
    0x07F00000,0x07F80000,0x07E00000,0x07B80000,0x07B00000,0x07800000,0x07C80000,0x07D80000,
    0x07280000,0x07400000,0x07080000,0x07680000,0x07500000,0x07180000,0x07200000,0x07100000,
    0x07700000,0x07780000,0x07600000,0x07380000,0x07300000,0x07000000,0x07480000,0x07580000,
    0x02280000,0x02400000,0x02080000,0x02680000,0x02500000,0x02180000,0x02200000,0x02100000,
    0x02700000,0x02780000,0x02600000,0x02380000,0x02300000,0x02000000,0x02480000,0x02580000,
    0x03280000,0x03400000,0x03080000,0x03680000,0x03500000,0x03180000,0x03200000,0x03100000,
    0x03700000,0x03780000,0x03600000,0x03380000,0x03300000,0x03000000,0x03480000,0x03580000,
    0x06280000,0x06400000,0x06080000,0x06680000,0x06500000,0x06180000,0x06200000,0x06100000,
    0x06700000,0x06780000,0x06600000,0x06380000,0x06300000,0x06000000,0x06480000,0x06580000,
    0x05A80000,0x05C00000,0x05880000,0x05E80000,0x05D00000,0x05980000,0x05A00000,0x05900000,
    0x05F00000,0x05F80000,0x05E00000,0x05B80000,0x05B00000,0x05800000,0x05C80000,0x05D80000,
    0x01280000,0x01400000,0x01080000,0x01680000,0x01500000,0x01180000,0x01200000,0x01100000,
    0x01700000,0x01780000,0x01600000,0x01380000,0x01300000,0x01000000,0x01480000,0x01580000,
    0x02A80000,0x02C00000,0x02880000,0x02E80000,0x02D00000,0x02980000,0x02A00000,0x02900000,
    0x02F00000,0x02F80000,0x02E00000,0x02B80000,0x02B00000,0x02800000,0x02C80000,0x02D80000,
    0x01A80000,0x01C00000,0x01880000,0x01E80000,0x01D00000,0x01980000,0x01A00000,0x01900000,
    0x01F00000,0x01F80000,0x01E00000,0x01B80000,0x01B00000,0x01800000,0x01C80000,0x01D80000
    },{
    0x30000002,0x60000002,0x38000002,0x08000002,0x28000002,0x78000002,0x68000002,0x40000002,
    0x20000002,0x50000002,0x48000002,0x70000002,0x00000002,0x18000002,0x58000002,0x10000002,
    0xB0000005,0xE0000005,0xB8000005,0x88000005,0xA8000005,0xF8000005,0xE8000005,0xC0000005,
    0xA0000005,0xD0000005,0xC8000005,0xF0000005,0x80000005,0x98000005,0xD8000005,0x90000005,
    0x30000005,0x60000005,0x38000005,0x08000005,0x28000005,0x78000005,0x68000005,0x40000005,
    0x20000005,0x50000005,0x48000005,0x70000005,0x00000005,0x18000005,0x58000005,0x10000005,
    0x30000000,0x60000000,0x38000000,0x08000000,0x28000000,0x78000000,0x68000000,0x40000000,
    0x20000000,0x50000000,0x48000000,0x70000000,0x00000000,0x18000000,0x58000000,0x10000000,
    0xB0000003,0xE0000003,0xB8000003,0x88000003,0xA8000003,0xF8000003,0xE8000003,0xC0000003,
    0xA0000003,0xD0000003,0xC8000003,0xF0000003,0x80000003,0x98000003,0xD8000003,0x90000003,
    0x30000001,0x60000001,0x38000001,0x08000001,0x28000001,0x78000001,0x68000001,0x40000001,
    0x20000001,0x50000001,0x48000001,0x70000001,0x00000001,0x18000001,0x58000001,0x10000001,
    0xB0000000,0xE0000000,0xB8000000,0x88000000,0xA8000000,0xF8000000,0xE8000000,0xC0000000,
    0xA0000000,0xD0000000,0xC8000000,0xF0000000,0x80000000,0x98000000,0xD8000000,0x90000000,
    0xB0000006,0xE0000006,0xB8000006,0x88000006,0xA8000006,0xF8000006,0xE8000006,0xC0000006,
    0xA0000006,0xD0000006,0xC8000006,0xF0000006,0x80000006,0x98000006,0xD8000006,0x90000006,
    0xB0000001,0xE0000001,0xB8000001,0x88000001,0xA8000001,0xF8000001,0xE8000001,0xC0000001,
    0xA0000001,0xD0000001,0xC8000001,0xF0000001,0x80000001,0x98000001,0xD8000001,0x90000001,
    0x30000003,0x60000003,0x38000003,0x08000003,0x28000003,0x78000003,0x68000003,0x40000003,
    0x20000003,0x50000003,0x48000003,0x70000003,0x00000003,0x18000003,0x58000003,0x10000003,
    0x30000004,0x60000004,0x38000004,0x08000004,0x28000004,0x78000004,0x68000004,0x40000004,
    0x20000004,0x50000004,0x48000004,0x70000004,0x00000004,0x18000004,0x58000004,0x10000004,
    0xB0000002,0xE0000002,0xB8000002,0x88000002,0xA8000002,0xF8000002,0xE8000002,0xC0000002,
    0xA0000002,0xD0000002,0xC8000002,0xF0000002,0x80000002,0x98000002,0xD8000002,0x90000002,
    0xB0000004,0xE0000004,0xB8000004,0x88000004,0xA8000004,0xF8000004,0xE8000004,0xC0000004,
    0xA0000004,0xD0000004,0xC8000004,0xF0000004,0x80000004,0x98000004,0xD8000004,0x90000004,
    0x30000006,0x60000006,0x38000006,0x08000006,0x28000006,0x78000006,0x68000006,0x40000006,
    0x20000006,0x50000006,0x48000006,0x70000006,0x00000006,0x18000006,0x58000006,0x10000006,
    0xB0000007,0xE0000007,0xB8000007,0x88000007,0xA8000007,0xF8000007,0xE8000007,0xC0000007,
    0xA0000007,0xD0000007,0xC8000007,0xF0000007,0x80000007,0x98000007,0xD8000007,0x90000007,
    0x30000007,0x60000007,0x38000007,0x08000007,0x28000007,0x78000007,0x68000007,0x40000007,
    0x20000007,0x50000007,0x48000007,0x70000007,0x00000007,0x18000007,0x58000007,0x10000007
    },{
    0x000000E8,0x000000D8,0x000000A0,0x00000088,0x00000098,0x000000F8,0x000000A8,0x000000C8,
    0x00000080,0x000000D0,0x000000F0,0x000000B8,0x000000B0,0x000000C0,0x00000090,0x000000E0,
    0x000007E8,0x000007D8,0x000007A0,0x00000788,0x00000798,0x000007F8,0x000007A8,0x000007C8,
    0x00000780,0x000007D0,0x000007F0,0x000007B8,0x000007B0,0x000007C0,0x00000790,0x000007E0,
    0x000006E8,0x000006D8,0x000006A0,0x00000688,0x00000698,0x000006F8,0x000006A8,0x000006C8,
    0x00000680,0x000006D0,0x000006F0,0x000006B8,0x000006B0,0x000006C0,0x00000690,0x000006E0,
    0x00000068,0x00000058,0x00000020,0x00000008,0x00000018,0x00000078,0x00000028,0x00000048,
    0x00000000,0x00000050,0x00000070,0x00000038,0x00000030,0x00000040,0x00000010,0x00000060,
    0x000002E8,0x000002D8,0x000002A0,0x00000288,0x00000298,0x000002F8,0x000002A8,0x000002C8,
    0x00000280,0x000002D0,0x000002F0,0x000002B8,0x000002B0,0x000002C0,0x00000290,0x000002E0,
    0x000003E8,0x000003D8,0x000003A0,0x00000388,0x00000398,0x000003F8,0x000003A8,0x000003C8,
    0x00000380,0x000003D0,0x000003F0,0x000003B8,0x000003B0,0x000003C0,0x00000390,0x000003E0,
    0x00000568,0x00000558,0x00000520,0x00000508,0x00000518,0x00000578,0x00000528,0x00000548,
    0x00000500,0x00000550,0x00000570,0x00000538,0x00000530,0x00000540,0x00000510,0x00000560,
    0x00000268,0x00000258,0x00000220,0x00000208,0x00000218,0x00000278,0x00000228,0x00000248,
    0x00000200,0x00000250,0x00000270,0x00000238,0x00000230,0x00000240,0x00000210,0x00000260,
    0x000004E8,0x000004D8,0x000004A0,0x00000488,0x00000498,0x000004F8,0x000004A8,0x000004C8,
    0x00000480,0x000004D0,0x000004F0,0x000004B8,0x000004B0,0x000004C0,0x00000490,0x000004E0,
    0x00000168,0x00000158,0x00000120,0x00000108,0x00000118,0x00000178,0x00000128,0x00000148,
    0x00000100,0x00000150,0x00000170,0x00000138,0x00000130,0x00000140,0x00000110,0x00000160,
    0x000001E8,0x000001D8,0x000001A0,0x00000188,0x00000198,0x000001F8,0x000001A8,0x000001C8,
    0x00000180,0x000001D0,0x000001F0,0x000001B8,0x000001B0,0x000001C0,0x00000190,0x000001E0,
    0x00000768,0x00000758,0x00000720,0x00000708,0x00000718,0x00000778,0x00000728,0x00000748,
    0x00000700,0x00000750,0x00000770,0x00000738,0x00000730,0x00000740,0x00000710,0x00000760,
    0x00000368,0x00000358,0x00000320,0x00000308,0x00000318,0x00000378,0x00000328,0x00000348,
    0x00000300,0x00000350,0x00000370,0x00000338,0x00000330,0x00000340,0x00000310,0x00000360,
    0x000005E8,0x000005D8,0x000005A0,0x00000588,0x00000598,0x000005F8,0x000005A8,0x000005C8,
    0x00000580,0x000005D0,0x000005F0,0x000005B8,0x000005B0,0x000005C0,0x00000590,0x000005E0,
    0x00000468,0x00000458,0x00000420,0x00000408,0x00000418,0x00000478,0x00000428,0x00000448,
    0x00000400,0x00000450,0x00000470,0x00000438,0x00000430,0x00000440,0x00000410,0x00000460,
    0x00000668,0x00000658,0x00000620,0x00000608,0x00000618,0x00000678,0x00000628,0x00000648,
    0x00000600,0x00000650,0x00000670,0x00000638,0x00000630,0x00000640,0x00000610,0x00000660
    }};

///////////////////////////////////////////////////////////////////////////////
// Misc Routines

//-----------------------------------------------------------------------------

string GetCipherModeStr(CIPHER_MODE mode)
{
    switch (mode)
    {
    case CM_CTSx:  return "CM_CTSx";
    case CM_CBCx:  return "CM_CBCx";
    case CM_CFB8:  return "CM_CFB8";
    case CM_CFBx:  return "CM_CFBx";
    case CM_OFB8:  return "CM_OFB8";
    case CM_OFBx:  return "CM_OFBx";
    case CM_CFS8:  return "CM_CFS8";
    case CM_CFSx:  return "CM_CFSx";
    case CM_ECBx:  return "CM_ECBx";
    }

    return "";
}

//-----------------------------------------------------------------------------

void hashingOverflowError()
{
    iseThrowDataAlgoException(S_HASHING_OVERFLOW_ERROR);
}

//-----------------------------------------------------------------------------

void invalidMessageLength(Cipher *cipher)
{
    iseThrowDataAlgoException(formatString(
        S_INVALID_MESSAGE_LENGTH,
        GetCipherModeStr(cipher->getMode()).c_str(), cipher->context().blockSize).c_str());
}

//-----------------------------------------------------------------------------

int tableFind(char ch, const char *table, int tableSize)
{
    int result = -1;
    for (int i = 0; i < tableSize; i++)
        if (table[i] == ch)
        {
            result = i;
            break;
        }
    return result;
}

//-----------------------------------------------------------------------------

void protectBuffer(PVOID buffer, int size)
{
    static const int WIPE_COUNT = 4;
    static const BYTE WIPE_BYTES [WIPE_COUNT] = {0x55, 0xAA, 0xFF, 0x00};

    if (size > 0)
    {
        for (int i = 0; i < WIPE_COUNT; i++)
            memset(buffer, WIPE_BYTES[i], size);
    }
}

//-----------------------------------------------------------------------------

void protectBinary(binary& data)
{
    if (!data.empty())
    {
        protectBuffer((char*)data.c_str(), (int)data.length());
        data.clear();
    }
}

//-----------------------------------------------------------------------------

void increment8(PDWORD value, DWORD addVal)
{
#ifdef ISE_WINDOWS
    __asm
    {
        MOV  EAX, value
        MOV  EDX, addVal
        MOV  ECX, EDX
        LEA  EDX, [EDX * 8]
        SHR  ECX, 25
        ADD  [EAX][ 0], EDX
        ADC  [EAX][ 4], ECX
        ADC  [EAX][ 8], 0
        ADC  [EAX][12], 0
        ADC  [EAX][16], 0
        ADC  [EAX][20], 0
        ADC  [EAX][24], 0
        ADC  [EAX][28], 0
        JC   _001
        JMP  _002
    _001:
        CALL hashingOverflowError
    _002:
        NOP
    }
#endif
#ifdef ISE_LINUX
    UINT ok = 0;

    __asm__ __volatile
    (
        "\
        shr    $25, %%ecx; \
        add    %%edx, (%%eax); \
        adc    %%ecx, 4(%%eax); \
        adc    $0, 8(%%eax); \
        adc    $0, 12(%%eax); \
        adc    $0, 16(%%eax); \
        adc    $0, 20(%%eax); \
        adc    $0, 24(%%eax); \
        adc    $0, 28(%%eax); \
        jc     1f; \
        jmp    2f; \
    1: \
        mov    $0, %%eax; \
        jmp    3f; \
    2: \
        mov    $1, %%eax; \
    3: \
        nop; \
        "
            : "=a"(ok)
            : "a"(value), "c"(addVal), "d"(addVal*8)
    );

    if (!ok)
        hashingOverflowError();
#endif
}

//-----------------------------------------------------------------------------

DWORD swapDWord(DWORD v)
{
    return (v << 24) | (v >> 24) | ((v << 8) & 0x00FF0000) | ((v >> 8) & 0x0000FF00);
}

//-----------------------------------------------------------------------------

WORD swapWord(WORD v)
{
    return static_cast<WORD>(((v << 8) & 0xFF00) | ((v >> 8) & 0x00FF));
}

//-----------------------------------------------------------------------------

void swapDWordBuffer(const PDWORD source, PDWORD dest, int count)
{
    for (int i = 0; i < count; i++)
    {
        DWORD t = source[i];
        dest[i] = (t << 24) | (t >> 24) | ((t << 8) & 0x00FF0000) | ((t >> 8) & 0x0000FF00);
    }
}

//-----------------------------------------------------------------------------

void xorBuffer(PBYTE src1, PBYTE src2, int size, PBYTE dest)
{
    for (int i = 0; i < size; i++)
        dest[i] = (src1[i] ^ src2[i]);
}

//-----------------------------------------------------------------------------

Format* createFormatObject(FORMAT_TYPE formatType)
{
    Format *result = NULL;

    switch (formatType)
    {
    case FT_COPY:     result = new Format_Copy();    break;
    case FT_HEX:      result = new Format_HEX();     break;
    case FT_HEXL:     result = new Format_HEXL();    break;
    case FT_MIME32:   result = new Format_MIME32();  break;
    case FT_MIME64:   result = new Format_MIME64();  break;
    default:
        iseThrowDataAlgoException(formatString(S_INVALID_FORMAT_TYPE, formatType).c_str());
        break;
    }

    return result;
}

//-----------------------------------------------------------------------------

Hash* createHashObject(HASH_TYPE hashType)
{
    Hash *result = NULL;

    switch (hashType)
    {
    case HT_MD4:     result = new Hash_MD4();    break;
    case HT_MD5:     result = new Hash_MD5();    break;
    case HT_SHA:     result = new Hash_SHA();    break;
    case HT_SHA1:    result = new Hash_SHA1();   break;
    default:
        iseThrowDataAlgoException(formatString(S_INVALID_HASH_TYPE, hashType).c_str());
        break;
    }

    return result;
}

//-----------------------------------------------------------------------------

Cipher* createCipherObject(CIPHER_TYPE cipherType)
{
    Cipher *result = NULL;

    switch (cipherType)
    {
    case CT_NULL:     result = new Cipher_Null();        break;
    case CT_BLOWFISH: result = new Cipher_Blowfish();    break;
    case CT_IDEA:     result = new Cipher_IDEA();        break;
    case CT_DES:      result = new Cipher_DES();         break;
    case CT_GOST:     result = new Cipher_Gost();        break;
    default:
        iseThrowDataAlgoException(formatString(S_INVALID_CIPHER_TYPE, cipherType).c_str());
        break;
    }

    return result;
}

//-----------------------------------------------------------------------------

binary hashString(HASH_TYPE hashType, const binary& sourceStr, PVOID digest)
{
    return hashBuffer(hashType, (char*)sourceStr.c_str(), (int)sourceStr.length(), digest);
}

//-----------------------------------------------------------------------------

binary hashBuffer(HASH_TYPE hashType, PVOID buffer, int dataSize, PVOID digest)
{
    std::auto_ptr<Hash> hashObj(createHashObject(hashType));

    binary s = hashObj->calcBuffer(buffer, dataSize, FT_COPY);
    if (digest)
        memmove(digest, s.c_str(), hashObj->digestSize());

    Format_HEX formatObj;
    return formatObj.encode(s);
}

//-----------------------------------------------------------------------------

binary hashStream(HASH_TYPE hashType, Stream& stream, PVOID digest)
{
    std::auto_ptr<Hash> hashObj(createHashObject(hashType));

    binary s = hashObj->calcStream(stream, -1, FT_COPY);
    if (digest)
        memmove(digest, s.c_str(), hashObj->digestSize());

    Format_HEX formatObj;
    return formatObj.encode(s);
}

//-----------------------------------------------------------------------------

binary hashFile(HASH_TYPE hashType, char *fileName, PVOID digest)
{
    std::auto_ptr<Hash> hashObj(createHashObject(hashType));

    binary s = hashObj->calcFile(fileName, FT_COPY);
    if (digest)
        memmove(digest, s.c_str(), hashObj->digestSize());

    Format_HEX formatObj;
    return formatObj.encode(s);
}

//-----------------------------------------------------------------------------

binary md5(const binary& sourceStr)
{
    return hashString(HT_MD5, sourceStr);
}

//-----------------------------------------------------------------------------

binary md5(PVOID buffer, int dataSize)
{
    return hashBuffer(HT_MD5, buffer, dataSize);
}

//-----------------------------------------------------------------------------

binary md5(Stream& stream)
{
    return hashStream(HT_MD5, stream);
}

//-----------------------------------------------------------------------------

binary md5(char *fileName)
{
    return hashFile(HT_MD5, fileName);
}

//-----------------------------------------------------------------------------

static DWORD crc32(DWORD Crc, PVOID data, int dataSize, CRC32_TYPE crc32Type)
{
    if (crc32Type == CRC32_STANDARD)
    {
        // This polynomial (0xedb88320)
        static const DWORD CRC_TABLE[] = {
            0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
            0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
            0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
            0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
            0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
            0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
            0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
            0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
            0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
            0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
            0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
            0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
            0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
            0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
            0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
            0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
            0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
            0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
            0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
            0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
            0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
            0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
            0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
            0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
            0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
            0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
            0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
            0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
            0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
            0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
            0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
            0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
            0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
            0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
            0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
            0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
            0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
            0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
            0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
            0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
            0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
            0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
            0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
            0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
            0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
            0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
            0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
            0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
            0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
            0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
            0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
            0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
            0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
            0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
            0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
            0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
            0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
            0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
            0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
            0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
            0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
            0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
            0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
            0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
        };

        PBYTE p = (PBYTE)data;
        for (int i = 0; i < dataSize; i++)
            Crc = CRC_TABLE[(Crc ^ p[i]) & 0xFF] ^ (Crc >> 8);
        Crc ^= 0xFFFFFFFF;
    }
    else if (crc32Type == CRC32_SPECIAL)
    {
        // This polynomial (0x04c11db7)
        static const DWORD CRC_TABLE[] = {
            0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
            0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
            0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
            0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
            0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
            0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
            0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
            0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
            0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
            0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
            0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
            0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
            0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
            0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
            0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
            0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
            0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
            0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
            0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
            0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
            0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
            0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
            0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
            0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
            0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
            0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
            0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
            0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
            0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
            0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
            0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
            0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
            0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
            0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
            0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
            0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
            0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
            0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
            0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
            0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
            0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
            0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
            0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
            0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
            0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
            0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
            0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
            0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
            0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
            0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
            0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
            0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
            0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
            0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
            0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
            0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
            0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
            0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
            0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
            0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
            0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
            0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
            0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
            0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
        };

        PBYTE p = (PBYTE)data;
        for (int i = 0; i < dataSize; i++)
            Crc = (Crc << 8) ^ CRC_TABLE[((Crc >> 24) ^ *p++) & 0xFF];
    }
    else
    {
        // wrong crc32 type
        ISE_ASSERT(false);
        Crc = 0;
    }

    return Crc;
}

//-----------------------------------------------------------------------------

DWORD calcCrc32(PVOID data, int dataSize, DWORD lastResult, CRC32_TYPE crc32Type)
{
    return crc32(lastResult, data, dataSize, crc32Type);
}

//-----------------------------------------------------------------------------

BYTE calcCrc8(PVOID data, int dataSize)
{
    char *p = (char*)data;
    BYTE result = 0;

    while (dataSize--)
    {
        result ^= static_cast<BYTE>(*p++);
        for (int i = 0; i < 8; ++i)
        {
            if (result & 0x01)
                result = static_cast<BYTE>((result >> 1) ^ 0x8C);
            else
                result >>= 1;
        }
    }

    return result;
}

//-----------------------------------------------------------------------------

void encryptBuffer(CIPHER_TYPE cipherType, PVOID source, PVOID dest, int dataSize, char *key)
{
    std::auto_ptr<Cipher> cipherObj(createCipherObject(cipherType));
    binary keyStr = (key? key : "");

    cipherObj->init(keyStr);
    cipherObj->encode(source, dest, dataSize);
    cipherObj->done();
}

//-----------------------------------------------------------------------------

void decryptBuffer(CIPHER_TYPE cipherType, PVOID source, PVOID dest, int dataSize, char *key)
{
    std::auto_ptr<Cipher> cipherObj(createCipherObject(cipherType));
    binary keyStr = (key? key : "");

    cipherObj->init(keyStr);
    cipherObj->decode(source, dest, dataSize);
    cipherObj->done();
}

//-----------------------------------------------------------------------------

void encryptStream(CIPHER_TYPE cipherType, Stream& srcStream, Stream& destStream, char *key)
{
    std::auto_ptr<Cipher> cipherObj(createCipherObject(cipherType));
    binary keyStr = (key? key : "");

    cipherObj->init(keyStr);
    cipherObj->encodeStream(srcStream, destStream, -1);
    cipherObj->done();
}

//-----------------------------------------------------------------------------

void decryptStream(CIPHER_TYPE cipherType, Stream& srcStream, Stream& destStream, char *key)
{
    std::auto_ptr<Cipher> cipherObj(createCipherObject(cipherType));
    binary keyStr = (key? key : "");

    cipherObj->init(keyStr);
    cipherObj->decodeStream(srcStream, destStream, -1);
    cipherObj->done();
}

//-----------------------------------------------------------------------------

void encryptFile(CIPHER_TYPE cipherType, char *srcFileName, char *destFileName, char *key)
{
    std::auto_ptr<Cipher> cipherObj(createCipherObject(cipherType));
    binary keyStr = (key? key : "");

    cipherObj->init(keyStr);
    cipherObj->encodeFile(srcFileName, destFileName);
    cipherObj->done();
}

//-----------------------------------------------------------------------------

void decryptFile(CIPHER_TYPE cipherType, char *srcFileName, char *destFileName, char *key)
{
    std::auto_ptr<Cipher> cipherObj(createCipherObject(cipherType));
    binary keyStr = (key? key : "");

    cipherObj->init(keyStr);
    cipherObj->decodeFile(srcFileName, destFileName);
    cipherObj->done();
}

//-----------------------------------------------------------------------------

binary base64Encode(PVOID data, int dataSize)
{
    if (dataSize < 0)
        dataSize = (int)strlen((char*)data);

    Format_MIME64 formatObj;
    return formatObj.encode(data, dataSize);
}

//-----------------------------------------------------------------------------

binary base64Decode(PVOID data, int dataSize)
{
    if (dataSize < 0)
        dataSize = (int)strlen((char*)data);

    Format_MIME64 formatObj;
    return formatObj.decode(data, dataSize);
}

//-----------------------------------------------------------------------------

binary base16Encode(PVOID data, int dataSize)
{
    if (dataSize < 0)
        dataSize = (int)strlen((char*)data);

    Format_HEX formatObj;
    return formatObj.encode(data, dataSize);
}

//-----------------------------------------------------------------------------

binary base16Decode(PVOID data, int dataSize)
{
    if (dataSize < 0)
        dataSize = (int)strlen((char*)data);

    Format_HEX formatObj;
    return formatObj.decode(data, dataSize);
}

///////////////////////////////////////////////////////////////////////////////
// Format

binary Format::encode(const binary& value)
{
    return doEncode((PVOID)value.c_str(), (int)value.size());
}

//-----------------------------------------------------------------------------

binary Format::encode(PVOID data, int size)
{
    return doEncode(data, size);
}

//-----------------------------------------------------------------------------

binary Format::decode(const binary& value)
{
    return doDecode((PVOID)value.c_str(), (int)value.size());
}

//-----------------------------------------------------------------------------

binary Format::decode(PVOID data, int size)
{
    return doDecode(data, size);
}

//-----------------------------------------------------------------------------

bool Format::isValid(const binary& value)
{
    return doIsValid((PVOID)value.c_str(), (int)value.size());
}

//-----------------------------------------------------------------------------

bool Format::isValid(PVOID data, int size)
{
    return doIsValid(data, size);
}

///////////////////////////////////////////////////////////////////////////////
// Format_Copy

binary Format_Copy::doEncode(PVOID data, int size)
{
    binary result((const char*)data, size);
    return result;
}

//-----------------------------------------------------------------------------

binary Format_Copy::doDecode(PVOID data, int size)
{
    binary result((const char*)data, size);
    return result;
}

//-----------------------------------------------------------------------------

bool Format_Copy::doIsValid(PVOID data, int size)
{
    return (size >= 0);
}

///////////////////////////////////////////////////////////////////////////////
// Format_HEX

binary Format_HEX::doEncode(PVOID data, int size)
{
    binary result;
    const char *t = charTable();
    unsigned char *s;
    char *d;

    if (size <= 0)
        return result;

    result.resize(size * 2);
    d = (char*)result.c_str();
    s = (unsigned char*)data;

    while (size > 0)
    {
        d[0] = t[*s >> 4];
        d[1] = t[*s & 0x0F];
        d += 2;
        s++;
        size--;
    }

    return result;
}

//-----------------------------------------------------------------------------

binary Format_HEX::doDecode(PVOID data, int size)
{
    binary result;
    const char *t = charTable();
    char *s;
    unsigned char *d;
    int i, p;
    bool hasIdent;

    if (size <= 0)
        return result;

    result.resize(size / 2 + 1);
    d = (unsigned char*)result.c_str();
    s = (char*)data;
    i = 0;
    hasIdent = false;

    while (size > 0)
    {
        p = tableFind(*s, t, 18);
        if (p < 0)
            p = tableFind(toupper(*s), t, 16);
        if (p < 0)
            iseThrowDataAlgoException(formatString(S_INVALID_STRING_FORMAT, "Format_HEX").c_str());

        s++;
        if (p >= 0)
        {
            if (p > 16)
            {
                if (!hasIdent)
                {
                    hasIdent = true;
                    i = 0;
                    d = (unsigned char*)result.c_str();
                }
            }
            else
            {
                if (i % 2 != 0)
                {
                    *d = *d | p;
                    d++;
                }
                else
                    *d = p << 4;
                i++;
            }
        }
        size--;
    }

    result.resize((char*)d - (char*)result.c_str());
    return result;
}

//-----------------------------------------------------------------------------

bool Format_HEX::doIsValid(PVOID data, int size)
{
    bool result = true;
    const char *t = charTable();
    int l = (int)strlen(t);
    char *s = (char*)data;

    while (result && (size > 0))
    {
        if (tableFind(*s, t, l) >= 0)
        {
            size--;
            s++;
        }
        else
            result = false;
    }

    return result;
}

//-----------------------------------------------------------------------------

const char* Format_HEX::charTable()
{
    // Table must be >= 18 Chars
    return
        "0123456789ABCDEF"
        "X$ abcdefhHx()[]{},;:-_/\\*+\"\'\x09\x10\x13\x0";
}

///////////////////////////////////////////////////////////////////////////////
// Format_HEXL

const char* Format_HEXL::charTable()
{
    // Table must be >= 18 Chars
    return
        "0123456789abcdef"
        "X$ ABCDEFhHx()[]{},;:-_/\\*+\"\'\x09\x10\x13\x0";
}

///////////////////////////////////////////////////////////////////////////////
// Format_MIME32

binary Format_MIME32::doEncode(PVOID data, int size)
{
    binary result;
    const char *t = charTable();
    unsigned char *s;
    char *d;
    int i;

    if (size <= 0)
        return result;

    size = size * 8;
    result.resize(size / 5 + 5);
    d = (char*)result.c_str();
    s = (unsigned char*)data;
    i = 0;

    while (i < size)
    {
        *d = t[ *((PWORD)(&s[i>>3])) >> (i&0x7) & 0x1F ];
        d++;
        i += 5;
    }

    result.resize((char*)d - (char*)result.c_str());
    return result;
}

//-----------------------------------------------------------------------------

binary Format_MIME32::doDecode(PVOID data, int size)
{
    binary result;
    const char *t = charTable();
    char *s, *d;
    int i, v;

    if (size <= 0)
        return result;

    result.resize(size * 5 / 8);
    d = (char*)result.c_str();
    memset(d, 0, result.length());
    s = (char*)data;
    size = size * 5;
    i = 0;

    while (i < size)
    {
        v = tableFind(*s, t, 32);
        if (v < 0)
            v = tableFind(toupper(*s), t, 32);
        if (v >= 0)
        {
            *((PWORD)(&d[i>>3])) |= (v << (i & 0x7));
            i += 5;
        }
        else
            size -= 5;
        s++;
    }

    result.resize(size / 8);
    return result;
}

//-----------------------------------------------------------------------------

const char* Format_MIME32::charTable()
{
    // Table must be >= 32 Chars
    return
        "abcdefghijklnpqrstuwxyz123456789"
        " =$()[]{},;:-_\\*\"\'\x09\x10\x13\x0";   // special and skipped chars
}

///////////////////////////////////////////////////////////////////////////////
// Format_MIME64

binary Format_MIME64::doEncode(PVOID data, int size)
{
    binary result;
    const char *t = charTable();
    char *d;
    unsigned char *s;
    DWORD b;
    int i;

    if (size <= 0)
        return result;

    result.resize(size * 4 / 3 + 4);
    d = (char*)result.c_str();
    s = (unsigned char*)data;

    while (size >= 3)
    {
        size -= 3;
        b = (s[0] << 16) | (s[1] << 8) | s[2];
        d[0] = t[ b >> 18 & 0x3F ];
        d[1] = t[ b >> 12 & 0x3F ];
        d[2] = t[ b >>  6 & 0x3F ];
        d[3] = t[ b       & 0x3F ];
        d += 4;
        s = &s[3];
    }

    while (size > 0)
    {
        b = 0;
        for (i = 0; i <= 2; i++)
        {
            b = b << 8;
            if (size > 0)
            {
                b |= s[0];
                s = &s[1];
            }
            size--;
        }
        for (i = 3; i >= 0; i--)
        {
            if (size < 0)
            {
                d[i] = t[64];
                size++;
            }
            else
                d[i] = t[ b & 0x3F ];
            b = b >> 6;
        }
        d += 4;
    }

    result.resize((char*)d - (char*)result.c_str());
    return result;
}

//-----------------------------------------------------------------------------

binary Format_MIME64::doDecode(PVOID data, int size)
{
    binary result;
    const char *t = charTable();
    char *s, *d, *l;
    int i, j;
    DWORD b;

    if (size <= 0)
        return result;

    result.assign((char*)data, size);
    d = (char*)result.c_str();
    s = d;
    l = s + size;
    j = 0;

    while (s < l)
    {
        b = 0;
        j = 4;
        while (j > 0 && s < l)
        {
            i = tableFind(*s, t, 65);
            s++;
            if (i >= 0)
            {
                if (i < 64)
                {
                    b = b << 6 | (BYTE)i;
                    j--;
                }
                else
                    l = s;
            }
        }

        if (j > 0)
        {
            if (j >= 4)
            {
                j = 0;
                break;
            }
            else
                b = b << (6 * j);
        }
        i = 2;
        while (i >= 0)
        {
            d[i] = (char)b;
            b = b >> 8;
            i--;
        }
        d += 3;
    }

    result.resize((char*)d - (char*)result.c_str() - j);
    return result;
}

//-----------------------------------------------------------------------------

const char* Format_MIME64::charTable()
{
    // Table must be >= 65 Chars
    return
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        " $()[]{},;:-_\\*\"\'\x09\x10\x13\x0";   // special and skipped chars
}

///////////////////////////////////////////////////////////////////////////////
// Hash

Hash::Hash() :
    buffer_(NULL),
    bufferSize_(0),
    bufferIndex_(0),
    paddingByte_(0)
{
    memset(count_, 0, sizeof(count_));
}

//-----------------------------------------------------------------------------

Hash::~Hash()
{
    delete[] buffer_;
    buffer_ = NULL;
}

//-----------------------------------------------------------------------------

void Hash::init()
{
    bufferIndex_ = 0;
    bufferSize_ = blockSize();
    buffer_ = new BYTE[bufferSize_];
    memset(buffer_, 0, bufferSize_);
    memset(count_, 0, sizeof(count_));
    doInit();
}

//-----------------------------------------------------------------------------

void Hash::calc(PVOID data, int dataSize)
{
    int remain;
    PBYTE source;

    if (dataSize <= 0) return;
    if (buffer_ == NULL)
        iseThrowDataAlgoException(S_HASH_NOT_INITIALIZED);

    increment8(count_, dataSize);
    source = (PBYTE)data;

    if (bufferIndex_ > 0)
    {
        remain = bufferSize_ - bufferIndex_;
        if (dataSize < remain)
        {
            memmove(buffer_ + bufferIndex_, source, dataSize);
            bufferIndex_ += dataSize;
            return;
        }
        memmove(buffer_ + bufferIndex_, source, remain);
        doTransform((DWORD*)buffer_);
        dataSize -= remain;
        source += remain;
    }

    while (dataSize >= bufferSize_)
    {
        doTransform((DWORD*)source);
        source += bufferSize_;
        dataSize -= bufferSize_;
    }

    memmove(buffer_, source, dataSize);
    bufferIndex_ = dataSize;
}

//-----------------------------------------------------------------------------

void Hash::done()
{
    doDone();
    protectBuffer(buffer_, bufferSize_);
    bufferSize_ = 0;
    delete[] buffer_;
    buffer_ = NULL;
}

//-----------------------------------------------------------------------------

binary Hash::digestStr(FORMAT_TYPE formatType)
{
    std::auto_ptr<Format> formatObj(createFormatObject(formatType));
    return formatObj->encode(&digest()[0], digestSize());
}

//-----------------------------------------------------------------------------

binary Hash::calcBuffer(PVOID buffer, int bufferSize, FORMAT_TYPE formatType)
{
    init();
    calc(buffer, bufferSize);
    done();
    return digestStr(formatType);
}

//-----------------------------------------------------------------------------

binary Hash::calcStream(Stream& stream, INT64 size, FORMAT_TYPE formatType, DataAlgoProgress *progress)
{
    binary result;
    binary buffer;
    int bytes;
    INT64 min = 0, max = 0, pos;

    init();
    if (size < 0)
    {
        stream.setPosition(0);
        size = stream.getSize();
        pos = 0;
    }
    else
        pos = stream.getPosition();

    bytes = STREAM_BUF_SIZE % bufferSize_;
    bytes = (bytes == 0 ? STREAM_BUF_SIZE : (STREAM_BUF_SIZE + bufferSize_ - bytes));
    buffer.resize((int)(bytes > size ? size : bytes));
    min = pos;
    max = pos + size;

    while (size > 0)
    {
        if (progress) progress->progress(min, max, pos);
        bytes = (int)buffer.length();
        if (bytes > size) bytes = (int)size;
        stream.readBuffer((char*)buffer.c_str(), bytes);
        calc((char*)buffer.c_str(), bytes);
        size -= bytes;
        pos += bytes;
    }
    done();
    if (progress) progress->progress(min, max, max);
    protectBinary(buffer);
    result = digestStr(formatType);

    return result;
}

//-----------------------------------------------------------------------------

binary Hash::calcBinary(const binary& data, FORMAT_TYPE formatType)
{
    return calcBuffer((char*)data.c_str(), (int)data.length(), formatType);
}

//-----------------------------------------------------------------------------

binary Hash::calcFile(char *fileName, FORMAT_TYPE formatType, DataAlgoProgress *progress)
{
    FileStream fileStream(fileName, FM_OPEN_READ | FM_SHARE_DENY_NONE);
    return calcStream(fileStream, fileStream.getSize(), formatType, progress);
}

///////////////////////////////////////////////////////////////////////////////
// HashBaseMD4

HashBaseMD4::HashBaseMD4()
{
    memset(digest_, 0, sizeof(digest_));
}

//-----------------------------------------------------------------------------

void HashBaseMD4::doInit()
{
    digest_[0] = 0x67452301;
    digest_[1] = 0xEFCDAB89;
    digest_[2] = 0x98BADCFE;
    digest_[3] = 0x10325476;
    digest_[4] = 0xC3D2E1F0;
    digest_[5] = 0x76543210;
    digest_[6] = 0xFEDCBA98;
    digest_[7] = 0x89ABCDEF;
    digest_[8] = 0x01234567;
    digest_[9] = 0x3C2D1E0F;
}

//-----------------------------------------------------------------------------

void HashBaseMD4::doDone()
{
    if (count_[2] | count_[3])
        hashingOverflowError();

    if (paddingByte_ == 0)
        paddingByte_ = 0x80;
    buffer_[bufferIndex_] = paddingByte_;
    bufferIndex_++;
    if (bufferIndex_ > bufferSize_ - 8)
    {
        memset(buffer_ + bufferIndex_, 0, bufferSize_ - bufferIndex_);
        doTransform((DWORD*)buffer_);
        bufferIndex_ = 0;
    }
    memset(buffer_ + bufferIndex_, 0, bufferSize_ - bufferIndex_);
    memmove(buffer_ + bufferSize_ - 8, count_, 8);
    doTransform((DWORD*)buffer_);
}

///////////////////////////////////////////////////////////////////////////////
// Hash_MD4

void Hash_MD4::doTransform(DWORD *buffer)
{
    const DWORD S1 = 0x5A827999;
    const DWORD S2 = 0x6ED9EBA1;

    DWORD a, b, c, d;

    a = digest_[0];
    b = digest_[1];
    c = digest_[2];
    d = digest_[3];

    a += (((b & c) | (~ b & d)) + buffer[ 0]); a = (a <<  3) | (a >> 29);
    d += (((a & b) | (~ a & c)) + buffer[ 1]); d = (d <<  7) | (d >> 25);
    c += (((d & a) | (~ d & b)) + buffer[ 2]); c = (c << 11) | (c >> 21);
    b += (((c & d) | (~ c & a)) + buffer[ 3]); b = (b << 19) | (b >> 13);
    a += (((b & c) | (~ b & d)) + buffer[ 4]); a = (a <<  3) | (a >> 29);
    d += (((a & b) | (~ a & c)) + buffer[ 5]); d = (d <<  7) | (d >> 25);
    c += (((d & a) | (~ d & b)) + buffer[ 6]); c = (c << 11) | (c >> 21);
    b += (((c & d) | (~ c & a)) + buffer[ 7]); b = (b << 19) | (b >> 13);
    a += (((b & c) | (~ b & d)) + buffer[ 8]); a = (a <<  3) | (a >> 29);
    d += (((a & b) | (~ a & c)) + buffer[ 9]); d = (d <<  7) | (d >> 25);
    c += (((d & a) | (~ d & b)) + buffer[10]); c = (c << 11) | (c >> 21);
    b += (((c & d) | (~ c & a)) + buffer[11]); b = (b << 19) | (b >> 13);
    a += (((b & c) | (~ b & d)) + buffer[12]); a = (a <<  3) | (a >> 29);
    d += (((a & b) | (~ a & c)) + buffer[13]); d = (d <<  7) | (d >> 25);
    c += (((d & a) | (~ d & b)) + buffer[14]); c = (c << 11) | (c >> 21);
    b += (((c & d) | (~ c & a)) + buffer[15]); b = (b << 19) | (b >> 13);

    a += (((b & c) | (b & d) | (c & d)) + buffer[ 0] + S1); a = (a <<  3) | (a >> 29);
    d += (((a & b) | (a & c) | (b & c)) + buffer[ 4] + S1); d = (d <<  5) | (d >> 27);
    c += (((d & a) | (d & b) | (a & b)) + buffer[ 8] + S1); c = (c <<  9) | (c >> 23);
    b += (((c & d) | (c & a) | (d & a)) + buffer[12] + S1); b = (b << 13) | (b >> 19);
    a += (((b & c) | (b & d) | (c & d)) + buffer[ 1] + S1); a = (a <<  3) | (a >> 29);
    d += (((a & b) | (a & c) | (b & c)) + buffer[ 5] + S1); d = (d <<  5) | (d >> 27);
    c += (((d & a) | (d & b) | (a & b)) + buffer[ 9] + S1); c = (c <<  9) | (c >> 23);
    b += (((c & d) | (c & a) | (d & a)) + buffer[13] + S1); b = (b << 13) | (b >> 19);
    a += (((b & c) | (b & d) | (c & d)) + buffer[ 2] + S1); a = (a <<  3) | (a >> 29);
    d += (((a & b) | (a & c) | (b & c)) + buffer[ 6] + S1); d = (d <<  5) | (d >> 27);
    c += (((d & a) | (d & b) | (a & b)) + buffer[10] + S1); c = (c <<  9) | (c >> 23);
    b += (((c & d) | (c & a) | (d & a)) + buffer[14] + S1); b = (b << 13) | (b >> 19);
    a += (((b & c) | (b & d) | (c & d)) + buffer[ 3] + S1); a = (a <<  3) | (a >> 29);
    d += (((a & b) | (a & c) | (b & c)) + buffer[ 7] + S1); d = (d <<  5) | (d >> 27);
    c += (((d & a) | (d & b) | (a & b)) + buffer[11] + S1); c = (c <<  9) | (c >> 23);
    b += (((c & d) | (c & a) | (d & a)) + buffer[15] + S1); b = (b << 13) | (b >> 19);

    a += ((b ^ c ^ d) + buffer[ 0] + S2); a = (a <<  3) | (a >> 29);
    d += ((a ^ b ^ c) + buffer[ 8] + S2); d = (d <<  9) | (d >> 23);
    c += ((d ^ a ^ b) + buffer[ 4] + S2); c = (c << 11) | (c >> 21);
    b += ((c ^ d ^ a) + buffer[12] + S2); b = (b << 15) | (b >> 17);
    a += ((b ^ c ^ d) + buffer[ 2] + S2); a = (a <<  3) | (a >> 29);
    d += ((a ^ b ^ c) + buffer[10] + S2); d = (d <<  9) | (d >> 23);
    c += ((d ^ a ^ b) + buffer[ 6] + S2); c = (c << 11) | (c >> 21);
    b += ((c ^ d ^ a) + buffer[14] + S2); b = (b << 15) | (b >> 17);
    a += ((b ^ c ^ d) + buffer[ 1] + S2); a = (a <<  3) | (a >> 29);
    d += ((a ^ b ^ c) + buffer[ 9] + S2); d = (d <<  9) | (d >> 23);
    c += ((d ^ a ^ b) + buffer[ 5] + S2); c = (c << 11) | (c >> 21);
    b += ((c ^ d ^ a) + buffer[13] + S2); b = (b << 15) | (b >> 17);
    a += ((b ^ c ^ d) + buffer[ 3] + S2); a = (a <<  3) | (a >> 29);
    d += ((a ^ b ^ c) + buffer[11] + S2); d = (d <<  9) | (d >> 23);
    c += ((d ^ a ^ b) + buffer[ 7] + S2); c = (c << 11) | (c >> 21);
    b += ((c ^ d ^ a) + buffer[15] + S2); b = (b << 15) | (b >> 17);

    digest_[0] += a;
    digest_[1] += b;
    digest_[2] += c;
    digest_[3] += d;
}

///////////////////////////////////////////////////////////////////////////////
// Hash_MD5

void Hash_MD5::doTransform(DWORD *buffer)
{
    DWORD a, b, c, d;

    a = digest_[0];
    b = digest_[1];
    c = digest_[2];
    d = digest_[3];

    a += (buffer[ 0] + 0xD76AA478 + (d ^ (b & (c ^ d))));   a = (a <<  7 | a >> 25) + b;
    d += (buffer[ 1] + 0xE8C7B756 + (c ^ (a & (b ^ c))));   d = (d << 12 | d >> 20) + a;
    c += (buffer[ 2] + 0x242070DB + (b ^ (d & (a ^ b))));   c = (c << 17 | c >> 15) + d;
    b += (buffer[ 3] + 0xC1BDCEEE + (a ^ (c & (d ^ a))));   b = (b << 22 | b >> 10) + c;
    a += (buffer[ 4] + 0xF57C0FAF + (d ^ (b & (c ^ d))));   a = (a <<  7 | a >> 25) + b;
    d += (buffer[ 5] + 0x4787C62A + (c ^ (a & (b ^ c))));   d = (d << 12 | d >> 20) + a;
    c += (buffer[ 6] + 0xA8304613 + (b ^ (d & (a ^ b))));   c = (c << 17 | c >> 15) + d;
    b += (buffer[ 7] + 0xFD469501 + (a ^ (c & (d ^ a))));   b = (b << 22 | b >> 10) + c;
    a += (buffer[ 8] + 0x698098D8 + (d ^ (b & (c ^ d))));   a = (a <<  7 | a >> 25) + b;
    d += (buffer[ 9] + 0x8B44F7AF + (c ^ (a & (b ^ c))));   d = (d << 12 | d >> 20) + a;
    c += (buffer[10] + 0xFFFF5BB1 + (b ^ (d & (a ^ b))));   c = (c << 17 | c >> 15) + d;
    b += (buffer[11] + 0x895CD7BE + (a ^ (c & (d ^ a))));   b = (b << 22 | b >> 10) + c;
    a += (buffer[12] + 0x6B901122 + (d ^ (b & (c ^ d))));   a = (a <<  7 | a >> 25) + b;
    d += (buffer[13] + 0xFD987193 + (c ^ (a & (b ^ c))));   d = (d << 12 | d >> 20) + a;
    c += (buffer[14] + 0xA679438E + (b ^ (d & (a ^ b))));   c = (c << 17 | c >> 15) + d;
    b += (buffer[15] + 0x49B40821 + (a ^ (c & (d ^ a))));   b = (b << 22 | b >> 10) + c;

    a += (buffer[ 1] + 0xF61E2562 + (c ^ (d & (b ^ c))));   a = (a <<  5 | a >> 27) + b;
    d += (buffer[ 6] + 0xC040B340 + (b ^ (c & (a ^ b))));   d = (d <<  9 | d >> 23) + a;
    c += (buffer[11] + 0x265E5A51 + (a ^ (b & (d ^ a))));   c = (c << 14 | c >> 18) + d;
    b += (buffer[ 0] + 0xE9B6C7Aa + (d ^ (a & (c ^ d))));   b = (b << 20 | b >> 12) + c;
    a += (buffer[ 5] + 0xD62F105D + (c ^ (d & (b ^ c))));   a = (a <<  5 | a >> 27) + b;
    d += (buffer[10] + 0x02441453 + (b ^ (c & (a ^ b))));   d = (d <<  9 | d >> 23) + a;
    c += (buffer[15] + 0xD8A1E681 + (a ^ (b & (d ^ a))));   c = (c << 14 | c >> 18) + d;
    b += (buffer[ 4] + 0xE7D3FBC8 + (d ^ (a & (c ^ d))));   b = (b << 20 | b >> 12) + c;
    a += (buffer[ 9] + 0x21E1CDE6 + (c ^ (d & (b ^ c))));   a = (a <<  5 | a >> 27) + b;
    d += (buffer[14] + 0xC33707D6 + (b ^ (c & (a ^ b))));   d = (d <<  9 | d >> 23) + a;
    c += (buffer[ 3] + 0xF4D50D87 + (a ^ (b & (d ^ a))));   c = (c << 14 | c >> 18) + d;
    b += (buffer[ 8] + 0x455A14ED + (d ^ (a & (c ^ d))));   b = (b << 20 | b >> 12) + c;
    a += (buffer[13] + 0xA9E3E905 + (c ^ (d & (b ^ c))));   a = (a <<  5 | a >> 27) + b;
    d += (buffer[ 2] + 0xFCEFA3F8 + (b ^ (c & (a ^ b))));   d = (d <<  9 | d >> 23) + a;
    c += (buffer[ 7] + 0x676F02D9 + (a ^ (b & (d ^ a))));   c = (c << 14 | c >> 18) + d;
    b += (buffer[12] + 0x8D2A4C8A + (d ^ (a & (c ^ d))));   b = (b << 20 | b >> 12) + c;

    a += (buffer[ 5] + 0xFFFA3942 + (b ^ c ^ d));   a = (a <<  4 | a >> 28) + b;
    d += (buffer[ 8] + 0x8771F681 + (a ^ b ^ c));   d = (d << 11 | d >> 21) + a;
    c += (buffer[11] + 0x6D9D6122 + (d ^ a ^ b));   c = (c << 16 | c >> 16) + d;
    b += (buffer[14] + 0xFDE5380C + (c ^ d ^ a));   b = (b << 23 | b >>  9) + c;
    a += (buffer[ 1] + 0xA4BEEA44 + (b ^ c ^ d));   a = (a <<  4 | a >> 28) + b;
    d += (buffer[ 4] + 0x4BDECFA9 + (a ^ b ^ c));   d = (d << 11 | d >> 21) + a;
    c += (buffer[ 7] + 0xF6BB4B60 + (d ^ a ^ b));   c = (c << 16 | c >> 16) + d;
    b += (buffer[10] + 0xBEBFBC70 + (c ^ d ^ a));   b = (b << 23 | b >>  9) + c;
    a += (buffer[13] + 0x289B7EC6 + (b ^ c ^ d));   a = (a <<  4 | a >> 28) + b;
    d += (buffer[ 0] + 0xEAA127FA + (a ^ b ^ c));   d = (d << 11 | d >> 21) + a;
    c += (buffer[ 3] + 0xD4EF3085 + (d ^ a ^ b));   c = (c << 16 | c >> 16) + d;
    b += (buffer[ 6] + 0x04881D05 + (c ^ d ^ a));   b = (b << 23 | b >>  9) + c;
    a += (buffer[ 9] + 0xD9D4D039 + (b ^ c ^ d));   a = (a <<  4 | a >> 28) + b;
    d += (buffer[12] + 0xE6DB99E5 + (a ^ b ^ c));   d = (d << 11 | d >> 21) + a;
    c += (buffer[15] + 0x1FA27CF8 + (d ^ a ^ b));   c = (c << 16 | c >> 16) + d;
    b += (buffer[ 2] + 0xC4AC5665 + (c ^ d ^ a));   b = (b << 23 | b >>  9) + c;

    a += (buffer[ 0] + 0xF4292244 + (c ^ (b | ~ d)));   a = (a <<  6 | a >> 26) + b;
    d += (buffer[ 7] + 0x432AFF97 + (b ^ (a | ~ c)));   d = (d << 10 | d >> 22) + a;
    c += (buffer[14] + 0xAB9423A7 + (a ^ (d | ~ b)));   c = (c << 15 | c >> 17) + d;
    b += (buffer[ 5] + 0xFC93A039 + (d ^ (c | ~ a)));   b = (b << 21 | b >> 11) + c;
    a += (buffer[12] + 0x655B59C3 + (c ^ (b | ~ d)));   a = (a <<  6 | a >> 26) + b;
    d += (buffer[ 3] + 0x8F0CCC92 + (b ^ (a | ~ c)));   d = (d << 10 | d >> 22) + a;
    c += (buffer[10] + 0xFFEFF47D + (a ^ (d | ~ b)));   c = (c << 15 | c >> 17) + d;
    b += (buffer[ 1] + 0x85845DD1 + (d ^ (c | ~ a)));   b = (b << 21 | b >> 11) + c;
    a += (buffer[ 8] + 0x6FA87E4F + (c ^ (b | ~ d)));   a = (a <<  6 | a >> 26) + b;
    d += (buffer[15] + 0xFE2CE6E0 + (b ^ (a | ~ c)));   d = (d << 10 | d >> 22) + a;
    c += (buffer[ 6] + 0xA3014314 + (a ^ (d | ~ b)));   c = (c << 15 | c >> 17) + d;
    b += (buffer[13] + 0x4E0811A1 + (d ^ (c | ~ a)));   b = (b << 21 | b >> 11) + c;
    a += (buffer[ 4] + 0xF7537E82 + (c ^ (b | ~ d)));   a = (a <<  6 | a >> 26) + b;
    d += (buffer[11] + 0xBD3AF235 + (b ^ (a | ~ c)));   d = (d << 10 | d >> 22) + a;
    c += (buffer[ 2] + 0x2AD7D2Bb + (a ^ (d | ~ b)));   c = (c << 15 | c >> 17) + d;
    b += (buffer[ 9] + 0xEB86D391 + (d ^ (c | ~ a)));   b = (b << 21 | b >> 11) + c;

    digest_[0] += a;
    digest_[1] += b;
    digest_[2] += c;
    digest_[3] += d;
}

///////////////////////////////////////////////////////////////////////////////
// Hash_SHA

Hash_SHA::Hash_SHA() :
    rotate_(false)
{
    // nothing
}

//-----------------------------------------------------------------------------

void Hash_SHA::doTransform(DWORD *buffer)
{
    DWORD a, b, c, d, e, t;
    DWORD w[80];
    int i;

    swapDWordBuffer(buffer, w, 16);
    if (!rotate_)
    {
        for (i = 16; i < 80; i++)
        {
            t = w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16];
            w[i] = t;
        }
    }
    else
    {
        for (i = 16; i < 80; i++)
        {
            t = w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16];
            w[i] = t << 1 | t >> 31;
        }
    }

    a = digest_[0];
    b = digest_[1];
    c = digest_[2];
    d = digest_[3];
    e = digest_[4];

    e += ((a << 5 | a >> 27) + (d ^ (b & (c ^ d))) + w[ 0] + 0x5A827999); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ (a & (b ^ c))) + w[ 1] + 0x5A827999); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ (e & (a ^ b))) + w[ 2] + 0x5A827999); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ (d & (e ^ a))) + w[ 3] + 0x5A827999); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ (c & (d ^ e))) + w[ 4] + 0x5A827999); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + (d ^ (b & (c ^ d))) + w[ 5] + 0x5A827999); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ (a & (b ^ c))) + w[ 6] + 0x5A827999); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ (e & (a ^ b))) + w[ 7] + 0x5A827999); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ (d & (e ^ a))) + w[ 8] + 0x5A827999); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ (c & (d ^ e))) + w[ 9] + 0x5A827999); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + (d ^ (b & (c ^ d))) + w[10] + 0x5A827999); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ (a & (b ^ c))) + w[11] + 0x5A827999); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ (e & (a ^ b))) + w[12] + 0x5A827999); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ (d & (e ^ a))) + w[13] + 0x5A827999); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ (c & (d ^ e))) + w[14] + 0x5A827999); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + (d ^ (b & (c ^ d))) + w[15] + 0x5A827999); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ (a & (b ^ c))) + w[16] + 0x5A827999); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ (e & (a ^ b))) + w[17] + 0x5A827999); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ (d & (e ^ a))) + w[18] + 0x5A827999); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ (c & (d ^ e))) + w[19] + 0x5A827999); c = c >> 2 | c << 30;

    e += ((a << 5 | a >> 27) + (d ^ b ^ c) + w[20] + 0x6ED9EBA1); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ a ^ b) + w[21] + 0x6ED9EBA1); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ e ^ a) + w[22] + 0x6ED9EBA1); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ d ^ e) + w[23] + 0x6ED9EBA1); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ c ^ d) + w[24] + 0x6ED9EBA1); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + (d ^ b ^ c) + w[25] + 0x6ED9EBA1); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ a ^ b) + w[26] + 0x6ED9EBA1); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ e ^ a) + w[27] + 0x6ED9EBA1); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ d ^ e) + w[28] + 0x6ED9EBA1); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ c ^ d) + w[29] + 0x6ED9EBA1); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + (d ^ b ^ c) + w[30] + 0x6ED9EBA1); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ a ^ b) + w[31] + 0x6ED9EBA1); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ e ^ a) + w[32] + 0x6ED9EBA1); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ d ^ e) + w[33] + 0x6ED9EBA1); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ c ^ d) + w[34] + 0x6ED9EBA1); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + (d ^ b ^ c) + w[35] + 0x6ED9EBA1); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ a ^ b) + w[36] + 0x6ED9EBA1); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ e ^ a) + w[37] + 0x6ED9EBA1); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ d ^ e) + w[38] + 0x6ED9EBA1); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ c ^ d) + w[39] + 0x6ED9EBA1); c = c >> 2 | c << 30;

    e += ((a << 5 | a >> 27) + ((b & c) | (d & (b | c))) + w[40] + 0x8F1BBCDC); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + ((a & b) | (c & (a | b))) + w[41] + 0x8F1BBCDC); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + ((e & a) | (b & (e | a))) + w[42] + 0x8F1BBCDC); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + ((d & e) | (a & (d | e))) + w[43] + 0x8F1BBCDC); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + ((c & d) | (e & (c | d))) + w[44] + 0x8F1BBCDC); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + ((b & c) | (d & (b | c))) + w[45] + 0x8F1BBCDC); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + ((a & b) | (c & (a | b))) + w[46] + 0x8F1BBCDC); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + ((e & a) | (b & (e | a))) + w[47] + 0x8F1BBCDC); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + ((d & e) | (a & (d | e))) + w[48] + 0x8F1BBCDC); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + ((c & d) | (e & (c | d))) + w[49] + 0x8F1BBCDC); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + ((b & c) | (d & (b | c))) + w[50] + 0x8F1BBCDC); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + ((a & b) | (c & (a | b))) + w[51] + 0x8F1BBCDC); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + ((e & a) | (b & (e | a))) + w[52] + 0x8F1BBCDC); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + ((d & e) | (a & (d | e))) + w[53] + 0x8F1BBCDC); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + ((c & d) | (e & (c | d))) + w[54] + 0x8F1BBCDC); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + ((b & c) | (d & (b | c))) + w[55] + 0x8F1BBCDC); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + ((a & b) | (c & (a | b))) + w[56] + 0x8F1BBCDC); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + ((e & a) | (b & (e | a))) + w[57] + 0x8F1BBCDC); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + ((d & e) | (a & (d | e))) + w[58] + 0x8F1BBCDC); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + ((c & d) | (e & (c | d))) + w[59] + 0x8F1BBCDC); c = c >> 2 | c << 30;

    e += ((a << 5 | a >> 27) + (d ^ b ^ c) + w[60] + 0xCA62C1D6); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ a ^ b) + w[61] + 0xCA62C1D6); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ e ^ a) + w[62] + 0xCA62C1D6); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ d ^ e) + w[63] + 0xCA62C1D6); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ c ^ d) + w[64] + 0xCA62C1D6); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + (d ^ b ^ c) + w[65] + 0xCA62C1D6); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ a ^ b) + w[66] + 0xCA62C1D6); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ e ^ a) + w[67] + 0xCA62C1D6); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ d ^ e) + w[68] + 0xCA62C1D6); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ c ^ d) + w[69] + 0xCA62C1D6); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + (d ^ b ^ c) + w[70] + 0xCA62C1D6); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ a ^ b) + w[71] + 0xCA62C1D6); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ e ^ a) + w[72] + 0xCA62C1D6); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ d ^ e) + w[73] + 0xCA62C1D6); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ c ^ d) + w[74] + 0xCA62C1D6); c = c >> 2 | c << 30;
    e += ((a << 5 | a >> 27) + (d ^ b ^ c) + w[75] + 0xCA62C1D6); b = b >> 2 | b << 30;
    d += ((e << 5 | e >> 27) + (c ^ a ^ b) + w[76] + 0xCA62C1D6); a = a >> 2 | a << 30;
    c += ((d << 5 | d >> 27) + (b ^ e ^ a) + w[77] + 0xCA62C1D6); e = e >> 2 | e << 30;
    b += ((c << 5 | c >> 27) + (a ^ d ^ e) + w[78] + 0xCA62C1D6); d = d >> 2 | d << 30;
    a += ((b << 5 | b >> 27) + (e ^ c ^ d) + w[79] + 0xCA62C1D6); c = c >> 2 | c << 30;

    digest_[0] += a;
    digest_[1] += b;
    digest_[2] += c;
    digest_[3] += d;
    digest_[4] += e;
}

//-----------------------------------------------------------------------------

void Hash_SHA::doDone()
{
    if (count_[2] | count_[3])
        hashingOverflowError();

    if (paddingByte_ == 0)
        paddingByte_ = 0x80;
    buffer_[bufferIndex_] = paddingByte_;
    bufferIndex_++;
    if (bufferIndex_ > bufferSize_ - 8)
    {
        memset(buffer_ + bufferIndex_, 0, bufferSize_ - bufferIndex_);
        doTransform((DWORD*)buffer_);
        bufferIndex_ = 0;
    }
    memset(buffer_ + bufferIndex_, 0, bufferSize_ - bufferIndex_);
    *((PDWORD)(&buffer_[bufferSize_ - 8])) = swapDWord(count_[1]);
    *((PDWORD)(&buffer_[bufferSize_ - 4])) = swapDWord(count_[0]);
    doTransform((DWORD*)buffer_);
    swapDWordBuffer(digest_, digest_, sizeof(digest_) / sizeof(DWORD));
}

///////////////////////////////////////////////////////////////////////////////
// Hash_SHA1

void Hash_SHA1::doTransform(DWORD *buffer)
{
    rotate_ = true;
    Hash_SHA::doTransform(buffer);
}

///////////////////////////////////////////////////////////////////////////////
// Cipher

Cipher::Cipher() :
    state_(CS_NEW),
    mode_(CM_CTSx),
    data_(NULL),
    dataSize_(0),
    bufferSize_(0),
    bufferIndex_(0),
    userSize_(0),
    buffer_(NULL),
    vector_(NULL),
    feedback_(NULL),
    user_(NULL),
    userSave_(NULL)
{
    // nothing
}

//-----------------------------------------------------------------------------

Cipher::~Cipher()
{
    delete[] data_;
    data_ = NULL;
    vector_ = NULL;
    feedback_ = NULL;
    buffer_ = NULL;
    user_ = NULL;
    userSave_ = NULL;
}

//-----------------------------------------------------------------------------

void Cipher::init(PVOID key, int size, PVOID iVector, int iVectorSize, BYTE iFiller)
{
    ensureInternalInit();
    protect();

    if (size > context().keySize)
        iseThrowDataAlgoException(S_KEY_MATERIAL_TOO_LARGE);
    if (iVectorSize > bufferSize_)
        iseThrowDataAlgoException(S_IVMATERIAL_TOO_LARGE);

    doInit(key, size);
    if (userSave_ != NULL)
        memmove(userSave_, user_, userSize_);

    memset(vector_, iFiller, bufferSize_);
    if (iVectorSize == 0)
    {
        doEncode(vector_, vector_, bufferSize_);
        if (userSave_ != NULL)
            memmove(user_, userSave_, userSize_);
    }
    else
        memmove(vector_, iVector, iVectorSize);

    memmove(feedback_, vector_, bufferSize_);
    state_ = CS_INITIALIZED;
}

//-----------------------------------------------------------------------------

void Cipher::init(const binary& key, const binary& iVector, BYTE iFiller)
{
    init((char*)key.c_str(), (int)key.length(), (char*)iVector.c_str(), (int)iVector.length(), iFiller);
}

//-----------------------------------------------------------------------------

void Cipher::done()
{
    ensureInternalInit();

    if (state_ != CS_DONE)
    {
        state_ = CS_DONE;
        bufferIndex_ = 0;
        doEncode(feedback_, buffer_, bufferSize_);
        memmove(feedback_, vector_, bufferSize_);
        if (userSave_ != NULL)
            memmove(user_, userSave_, userSize_);
    }
}

//-----------------------------------------------------------------------------

void Cipher::protect()
{
    state_ = CS_NEW;
    if (data_)
        protectBuffer(data_, dataSize_);
}

//-----------------------------------------------------------------------------

void Cipher::encode(PVOID source, PVOID dest, int dataSize)
{
    ensureInternalInit();
    checkState(CS_INITIALIZED | CS_ENCODE | CS_DONE);

    switch (mode_)
    {
    case CM_ECBx: encodeECBx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CBCx: encodeCBCx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CTSx: encodeCTSx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CFB8: encodeCFB8((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CFBx: encodeCFBx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_OFB8: encodeOFB8((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_OFBx: encodeOFBx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CFS8: encodeCFS8((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CFSx: encodeCFSx((PBYTE)source, (PBYTE)dest, dataSize); break;
    }
}

//-----------------------------------------------------------------------------

void Cipher::decode(PVOID source, PVOID dest, int dataSize)
{
    ensureInternalInit();
    checkState(CS_INITIALIZED | CS_DECODE | CS_DONE);

    switch (mode_)
    {
    case CM_ECBx: decodeECBx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CBCx: decodeCBCx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CTSx: decodeCTSx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CFB8: decodeCFB8((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CFBx: decodeCFBx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_OFB8: decodeOFB8((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_OFBx: decodeOFBx((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CFS8: decodeCFS8((PBYTE)source, (PBYTE)dest, dataSize); break;
    case CM_CFSx: decodeCFSx((PBYTE)source, (PBYTE)dest, dataSize); break;
    }
}

//-----------------------------------------------------------------------------

binary Cipher::encodeBinary(const binary& sourceStr, FORMAT_TYPE formatType)
{
    binary str;
    str.resize(sourceStr.length());
    encode((char*)sourceStr.c_str(), (char*)str.c_str(), (int)sourceStr.length());

    std::auto_ptr<Format> formatObj(createFormatObject(formatType));
    return formatObj->encode(str);
}

//-----------------------------------------------------------------------------

binary Cipher::decodeBinary(const binary& sourceStr, FORMAT_TYPE formatType)
{
    binary str;

    std::auto_ptr<Format> formatObj(createFormatObject(formatType));
    str = formatObj->decode(sourceStr);
    decode((char*)str.c_str(), (char*)str.c_str(), (int)str.length());

    return str;
}

//-----------------------------------------------------------------------------

void Cipher::encodeFile(char *srcFileName, char *destFileName, DataAlgoProgress *progress)
{
    doCodeFile(srcFileName, destFileName, context().blockSize, CK_ENCODE, progress);
}

//-----------------------------------------------------------------------------

void Cipher::decodeFile(char *srcFileName, char *destFileName, DataAlgoProgress *progress)
{
    doCodeFile(srcFileName, destFileName, context().blockSize, CK_DECODE, progress);
}

//-----------------------------------------------------------------------------

void Cipher::encodeStream(Stream& srcStream, Stream& destStream, INT64 dataSize, DataAlgoProgress *progress)
{
    doCodeStream(srcStream, destStream, dataSize, context().blockSize, CK_ENCODE, progress);
}

//-----------------------------------------------------------------------------

void Cipher::decodeStream(Stream& srcStream, Stream& destStream, INT64 dataSize, DataAlgoProgress *progress)
{
    doCodeStream(srcStream, destStream, dataSize, context().blockSize, CK_DECODE, progress);
}

//-----------------------------------------------------------------------------

void Cipher::setMode(CIPHER_MODE value)
{
    if (mode_ != value)
    {
        if ((state_ & (CS_NEW | CS_INITIALIZED | CS_DONE)) == 0)
            done();
        mode_ = value;
    }
}

//-----------------------------------------------------------------------------

void Cipher::checkState(DWORD states)
{
    if ((state_ & states) == 0)
    {
        if (state_ == CS_PADDED)
            iseThrowDataAlgoException(S_ALREADY_PADDED);
        else
            iseThrowDataAlgoException(S_INVALID_STATE);
    }
}

//-----------------------------------------------------------------------------

void Cipher::ensureInternalInit()
{
    if (data_ == NULL)
    {
        bool mustUserSaved;
        CipherContext context = this->context();

        bufferSize_ = context.bufferSize;
        userSize_ = context.userSize;
        mustUserSaved = context.userSave;

        dataSize_ = bufferSize_ * 3 + userSize_;
        if (mustUserSaved) dataSize_ += userSize_;

        data_ = new BYTE[dataSize_];
        if (data_)
        {
            memset(data_, 0, dataSize_);
            vector_ = data_;
            feedback_ = vector_ + bufferSize_;
            buffer_ = feedback_ + bufferSize_;
            user_ = buffer_ + bufferSize_;
            mode_ = DEFAULT_CIPHER_MODE;
            userSave_ = (mustUserSaved ? user_ + userSize_ : NULL);
            protect();
        }
    }
}

//-----------------------------------------------------------------------------

void Cipher::encodeECBx(PBYTE s, PBYTE d, int size)
{
    int i;

    if (context().blockSize == 1)
    {
        doEncode(s, d, size);
        state_ = CS_ENCODE;
    }
    else
    {
        size -= bufferSize_;
        i = 0;
        while (i <= size)
        {
            doEncode(s + i, d + i, bufferSize_);
            i += bufferSize_;
        }
        size -= (i - bufferSize_);
        if (size > 0)
        {
            if (size % context().blockSize == 0)
            {
                doEncode(s + i, d + i, size);
                state_ = CS_ENCODE;
            }
            else
            {
                state_ = CS_PADDED;
                invalidMessageLength(this);
            }
        }
    }
}

//-----------------------------------------------------------------------------

void Cipher::encodeCBCx(PBYTE s, PBYTE d, int size)
{
    PBYTE f;
    int i;

    size -= bufferSize_;
    f = feedback_;
    i = 0;
    while (i <= size)
    {
        xorBuffer(s + i, f, bufferSize_, d + i);
        f = d + i;
        doEncode(f, f, bufferSize_);
        i += bufferSize_;
    }
    if (f != feedback_)
        memmove(feedback_, f, bufferSize_);
    size -= (i - bufferSize_);
    if (size > 0)
    {	// padding
        encodeCFB8(s + i, d + i, size);
        state_ = CS_PADDED;
    }
    else
        state_ = CS_ENCODE;
}

//-----------------------------------------------------------------------------

void Cipher::encodeCTSx(PBYTE s, PBYTE d, int size)
{
    int i;

    size -= bufferSize_;
    i = 0;
    while (i <= size)
    {
        xorBuffer(s + i, feedback_, bufferSize_, d + i);
        doEncode(d + i, d + i, bufferSize_);
        xorBuffer(d + i, feedback_, bufferSize_, feedback_);
        i += bufferSize_;
    }
    size -= (i - bufferSize_);
    if (size > 0)
    {	// padding
        encodeCFS8(s + i, d + i, size);
        state_ = CS_PADDED;
    }
    else
        state_ = CS_ENCODE;
}

//-----------------------------------------------------------------------------

void Cipher::encodeCFB8(PBYTE s, PBYTE d, int size)
{
    int i = 0;

    while (i < size)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        memmove(feedback_, feedback_ + 1, bufferSize_ - 1);
        d[i] = s[i] ^ buffer_[0];
        feedback_[bufferSize_ - 1] = d[i];
        i++;
    }
    state_ = CS_ENCODE;
}

//-----------------------------------------------------------------------------

void Cipher::encodeCFBx(PBYTE s, PBYTE d, int size)
{
    int i;
    PBYTE f;

    state_ = CS_ENCODE;
    if (bufferIndex_ > 0)
    {
        i = bufferSize_ - bufferIndex_;
        if (i > size) i = size;
        xorBuffer(s, buffer_ + bufferIndex_, i, d);
        memmove(feedback_ + bufferIndex_, d, i);
        bufferIndex_ += i;
        if (bufferIndex_ < bufferSize_) return;

        size -= i;
        s = &s[i];
        d = &d[i];
        bufferIndex_ = 0;
    }

    size -= bufferSize_;
    f = feedback_;
    i = 0;
    while (i < size)
    {
        doEncode(f, buffer_, bufferSize_);
        xorBuffer(s + i, buffer_, bufferSize_, d + i);
        f = &d[i];
        i += bufferSize_;
    }
    if (f != feedback_)
        memmove(feedback_, f, bufferSize_);
    size -= (i - bufferSize_);
    if (size > 0)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        xorBuffer(s + i, buffer_, size, d + i);
        memmove(feedback_, d + i, size);
        bufferIndex_ = size;
    }
}

//-----------------------------------------------------------------------------

void Cipher::encodeOFB8(PBYTE s, PBYTE d, int size)
{
    int i = 0;

    while (i < size)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        memmove(feedback_, feedback_ + 1, bufferSize_ - 1);
        feedback_[bufferSize_ - 1] = buffer_[0];
        d[i] = s[i] ^ buffer_[0];
        i++;
    }
    state_ = CS_ENCODE;
}

//-----------------------------------------------------------------------------

void Cipher::encodeOFBx(PBYTE s, PBYTE d, int size)
{
    int i;

    state_ = CS_ENCODE;
    if (bufferIndex_ > 0)
    {
        i = bufferSize_ - bufferIndex_;
        if (i > size) i = size;
        xorBuffer(s, feedback_ + bufferIndex_, i, d);
        bufferIndex_ += i;
        if (bufferIndex_ < bufferSize_) return;

        size -= i;
        s = &s[i];
        d = &d[i];
        bufferIndex_ = 0;
    }
    size -= bufferSize_;
    i = 0;
    while (i < size)
    {
        doEncode(feedback_, feedback_, bufferSize_);
        xorBuffer(s + i, feedback_, bufferSize_, d + i);
        i += bufferSize_;
    }
    size -= (i - bufferSize_);
    if (size > 0)
    {
        doEncode(feedback_, feedback_, bufferSize_);
        xorBuffer(s + i, feedback_, size, d + i);
        bufferIndex_ = size;
    }
}

//-----------------------------------------------------------------------------

void Cipher::encodeCFS8(PBYTE s, PBYTE d, int size)
{
    int i = 0;

    while (i < size)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        d[i] = s[i] ^ buffer_[0];
        memmove(feedback_, feedback_ + 1, bufferSize_ - 1);
        feedback_[bufferSize_ - 1] ^= d[i];
        i++;
    }
    state_ = CS_ENCODE;
}

//-----------------------------------------------------------------------------

void Cipher::encodeCFSx(PBYTE s, PBYTE d, int size)
{
    int i;

    state_ = CS_ENCODE;
    if (bufferIndex_ > 0)
    {
        i = bufferSize_ - bufferIndex_;
        if (i > size) i = size;
        xorBuffer(s, buffer_ + bufferIndex_, i, d);
        xorBuffer(d, feedback_ + bufferIndex_, i, feedback_ + bufferIndex_);
        bufferIndex_ += i;
        if (bufferIndex_ < bufferSize_) return;

        size -= i;
        s = &s[i];
        d = &d[i];
        bufferIndex_ = 0;
    }
    size -= bufferSize_;
    i = 0;
    while (i < size)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        xorBuffer(s + i, buffer_, bufferSize_, d + i);
        xorBuffer(d + i, feedback_, bufferSize_, feedback_);
        i += bufferSize_;
    }
    size -= (i - bufferSize_);
    if (size > 0)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        xorBuffer(s + i, buffer_, size, d + i);
        xorBuffer(d + i, feedback_, size, feedback_);
        bufferIndex_ = size;
    }
}

//-----------------------------------------------------------------------------

void Cipher::decodeECBx(PBYTE s, PBYTE d, int size)
{
    int i;

    if (context().blockSize == 1)
    {
        doDecode(s, d, size);
        state_ = CS_DECODE;
    }
    else
    {
        size -= bufferSize_;
        i = 0;
        while (i <= size)
        {
            doDecode(s + i, d + i, bufferSize_);
            i += bufferSize_;
        }
        size -= (i - bufferSize_);
        if (size > 0)
        {
            if (size % context().blockSize == 0)
            {
                doDecode(s + i, d + i, size);
                state_ = CS_DECODE;
            }
            else
            {
                state_ = CS_PADDED;
                invalidMessageLength(this);
            }
        }
    }
}

//-----------------------------------------------------------------------------

void Cipher::decodeCBCx(PBYTE s, PBYTE d, int size)
{
    int i;
    PBYTE f, b, t;

    size -= bufferSize_;
    f = feedback_;
    i = 0;
    if (s == d)
    {
        b = buffer_;
        while (i <= size)
        {
            memmove(b, s + i, bufferSize_);
            doDecode(s + i, s + i, bufferSize_);
            xorBuffer(s + i, f, bufferSize_, s + i);
            t = f;
            f = b;
            b = t;
            i += bufferSize_;
        }
    }
    else
    {
        while (i <= size)
        {
            doDecode(s + i, d + i, bufferSize_);
            xorBuffer(f, d + i, bufferSize_, d + i);
            f = &s[i];
            i += bufferSize_;
        }
    }

    if (f != feedback_)
        memmove(feedback_, f, bufferSize_);
    size -= (i - bufferSize_);
    if (size > 0)
    {
        decodeCFB8(s + i, d + i, size);
        state_ = CS_PADDED;
    }
    else
        state_ = CS_DECODE;
}

//-----------------------------------------------------------------------------

void Cipher::decodeCTSx(PBYTE s, PBYTE d, int size)
{
    int i;
    PBYTE f, b, t;

    size -= bufferSize_;
    f = feedback_;
    b = buffer_;
    i = 0;
    while (i <= size)
    {
        xorBuffer(s + i, f, bufferSize_, b);
        doDecode(s + i, d + i, bufferSize_);
        xorBuffer(d + i, f, bufferSize_, d + i);
        t = b;
        b = f;
        f = t;
        i += bufferSize_;
    }
    if (f != feedback_)
        memmove(feedback_, f, bufferSize_);
    size -= (i - bufferSize_);
    if (size > 0)
    {
        decodeCFS8(s + i, d + i, size);
        state_ = CS_PADDED;
    }
    else
        state_ = CS_DECODE;
}

//-----------------------------------------------------------------------------

void Cipher::decodeCFB8(PBYTE s, PBYTE d, int size)
{
    int i = 0;

    while (i < size)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        memmove(feedback_, feedback_ + 1, bufferSize_ - 1);
        feedback_[bufferSize_ - 1] = s[i];
        d[i] = s[i] ^ buffer_[0];
        i++;
    }
    state_ = CS_DECODE;
}

//-----------------------------------------------------------------------------

void Cipher::decodeCFBx(PBYTE s, PBYTE d, int size)
{
    int i;
    PBYTE f;

    state_ = CS_DECODE;
    if (bufferIndex_ > 0)
    {	// remain bytes of last decode
        i = bufferSize_ - bufferIndex_;
        if (i > size) i = size;
        memmove(feedback_ + bufferIndex_, s, i);
        xorBuffer(s, buffer_ + bufferIndex_, i, d);
        bufferIndex_ += i;
        if (bufferIndex_ < bufferSize_) return;

        size -= i;
        s = &s[i];
        d = &d[i];
        bufferIndex_ = 0;
    }

    // process chunks of bufferSize_ bytes
    size -= bufferSize_;
    i = 0;
    if (s != d)
    {
        f = feedback_;
        while (i < size)
        {
            doEncode(f, buffer_, bufferSize_);
            xorBuffer(s + i, buffer_, bufferSize_, d + i);
            f = &s[i];
            i += bufferSize_;
        }
        if (f != feedback_)
            memmove(feedback_, f, bufferSize_);
    }
    else
    {
        while (i < size)
        {
            doEncode(feedback_, buffer_, bufferSize_);
            memmove(feedback_, s + i, bufferSize_);
            xorBuffer(s + i, buffer_, bufferSize_, d + i);
            i += bufferSize_;
        }
    }

    size -= (i - bufferSize_);
    if (size > 0)
    {	// remain bytes
        doEncode(feedback_, buffer_, bufferSize_);
        memmove(feedback_, s + i, size);
        xorBuffer(s + i, buffer_, size, d + i);
        bufferIndex_ = size;
    }
}

//-----------------------------------------------------------------------------

void Cipher::decodeOFB8(PBYTE s, PBYTE d, int size)
{
    int i = 0;

    while (i < size)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        memmove(feedback_, feedback_ + 1, bufferSize_ - 1);
        feedback_[bufferSize_ - 1] = buffer_[0];
        d[i] = s[i] ^ buffer_[0];
        i++;
    }
    state_ = CS_DECODE;
}

//-----------------------------------------------------------------------------

void Cipher::decodeOFBx(PBYTE s, PBYTE d, int size)
{
    int i;

    state_ = CS_DECODE;
    if (bufferIndex_ > 0)
    {
        i = bufferSize_ - bufferIndex_;
        if (i > size) i = size;
        xorBuffer(s, feedback_ + bufferIndex_, i, d);
        bufferIndex_ += i;
        if (bufferIndex_ < bufferSize_) return;

        size -= i;
        s = &s[i];
        d = &d[i];
        bufferIndex_ = 0;
    }
    size -= bufferSize_;
    i = 0;
    while (i < size)
    {
        doEncode(feedback_, feedback_, bufferSize_);
        xorBuffer(s + i, feedback_, bufferSize_, d + i);
        i += bufferSize_;
    }
    size -= (i - bufferSize_);
    if (size > 0)
    {
        doEncode(feedback_, feedback_, bufferSize_);
        xorBuffer(s + i, feedback_, size, d + i);
        bufferIndex_ = size;
    }
}

//-----------------------------------------------------------------------------

void Cipher::decodeCFS8(PBYTE s, PBYTE d, int size)
{
    int i = 0;

    while (i < size)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        memmove(feedback_, feedback_ + 1, bufferSize_ - 1);
        feedback_[bufferSize_ - 1] ^= s[i];
        d[i] = s[i] ^ buffer_[0];
        i++;
    }
    state_ = CS_DECODE;
}

//-----------------------------------------------------------------------------

void Cipher::decodeCFSx(PBYTE s, PBYTE d, int size)
{
    int i;

    state_ = CS_DECODE;
    if (bufferIndex_ > 0)
    {	// remain bytes of last decode
        i = bufferSize_ - bufferIndex_;
        if (i > size) i = size;
        xorBuffer(s, feedback_ + bufferIndex_, i, feedback_ + bufferIndex_);
        xorBuffer(s, buffer_ + bufferIndex_, i, d);
        bufferIndex_ += i;
        if (bufferIndex_ < bufferSize_) return;

        size -= i;
        s = &s[i];
        d = &d[i];
        bufferIndex_ = 0;
    }
    // process chunks of bufferSize_ bytes
    size -= bufferSize_;
    i = 0;
    while (i < size)
    {
        doEncode(feedback_, buffer_, bufferSize_);
        xorBuffer(s + i, feedback_, bufferSize_, feedback_);
        xorBuffer(s + i, buffer_, bufferSize_, d + i);
        i += bufferSize_;
    }
    size -= (i - bufferSize_);
    if (size > 0)
    {	// remain bytes
        doEncode(feedback_, buffer_, bufferSize_);
        xorBuffer(s + i, feedback_, size, feedback_);
        xorBuffer(s + i, buffer_, size, d + i);
        bufferIndex_ = size;
    }
}

//-----------------------------------------------------------------------------

void Cipher::doCodeStream(Stream& srcStream, Stream& destStream, INT64 size,
    int blockSize, CIPHER_KIND cipherKind, DataAlgoProgress *progress)
{
    binary buffer;
    int bufferSize, bytes;
    INT64 min, max, pos;

    pos = srcStream.getPosition();
    if (size < 0)
        size = srcStream.getSize() - pos;
    min = pos;
    max = pos + size;
    if (size > 0)
    {
        bufferSize = STREAM_BUF_SIZE % blockSize;
        bufferSize = (bufferSize == 0 ? STREAM_BUF_SIZE : STREAM_BUF_SIZE + blockSize - bufferSize);
        buffer.resize((int)(size > bufferSize ? bufferSize : size));

        while (size > 0)
        {
            if (progress) progress->progress(min, max, pos);
            bytes = bufferSize;
            if (bytes > size) bytes = (int)size;
            srcStream.readBuffer((char*)buffer.c_str(), bytes);

            if (cipherKind == CK_ENCODE)
                encode((char*)buffer.c_str(), (char*)buffer.c_str(), bytes);
            else
                decode((char*)buffer.c_str(), (char*)buffer.c_str(), bytes);

            destStream.writeBuffer((char*)buffer.c_str(), bytes);
            size -= bytes;
            pos += bytes;
        }
    }

    protectBinary(buffer);
    if (progress) progress->progress(min, max, max);
}

//-----------------------------------------------------------------------------

void Cipher::doCodeFile(char *srcFileName, char *destFileName,
    int blockSize, CIPHER_KIND cipherKind, DataAlgoProgress *progress)
{
    FileStream srcStream(srcFileName, FM_OPEN_READ | FM_SHARE_DENY_NONE);
    FileStream destStream(destFileName, FM_CREATE | FM_SHARE_DENY_WRITE);

    doCodeStream(srcStream, destStream, srcStream.getSize(), blockSize, cipherKind, progress);
}

///////////////////////////////////////////////////////////////////////////////
// Cipher_Null

void Cipher_Null::doInit(PVOID key, int size)
{
    // nothing
}

//-----------------------------------------------------------------------------

void Cipher_Null::doEncode(PVOID source, PVOID dest, int size)
{
    if (source != dest)
        memmove(dest, source, size);
}

//-----------------------------------------------------------------------------

void Cipher_Null::doDecode(PVOID source, PVOID dest, int size)
{
    if (source != dest)
        memmove(dest, source, size);
}

//-----------------------------------------------------------------------------

CipherContext Cipher_Null::context()
{
    CipherContext context;

    context.keySize = 0;
    context.blockSize = 1;
    context.bufferSize = 32;
    context.userSize = 0;
    context.userSave = false;

    return context;
}

///////////////////////////////////////////////////////////////////////////////
// Cipher_Blowfish

typedef DWORD BLOWFISH[4][256];
typedef BLOWFISH* PBLOWFISH;

//-----------------------------------------------------------------------------

void Cipher_Blowfish::doInit(PVOID key, int size)
{
    int i, j;
    DWORD b[2];
    PBYTE k;
    PDWORD p;
    PBLOWFISH s;

    k = (PBYTE)key;
    s = (PBLOWFISH)user_;
    p = (PDWORD)((PBYTE)user_ + sizeof(BLOWFISH_DATA));

    memmove(s, BLOWFISH_DATA, sizeof(BLOWFISH_DATA));
    memmove(p, BLOWFISH_KEY, sizeof(BLOWFISH_KEY));

    j = 0;
    if (size > 0)
    {
        for (i = 0; i < 18; i++)
        {
            p[i] ^=
                (k[(j + 0) % size] << 24) +
                (k[(j + 1) % size] << 16) +
                (k[(j + 2) % size] <<  8) +
                (k[(j + 3) % size] <<  0);
            j = (j + 4) % size;
        }
    }
    memset(b, 0, sizeof(b));
    for (i = 0; i < 9; i++)
    {
        doEncode(b, b, sizeof(b));
        p[i*2 + 0] = swapDWord(b[0]);
        p[i*2 + 1] = swapDWord(b[1]);
    }
    for (i = 0; i < 4; i++)
        for (j = 0; j < 128; j++)
        {
            doEncode(b, b, sizeof(b));
            (*s)[i][j*2 + 0] = swapDWord(b[0]);
            (*s)[i][j*2 + 1] = swapDWord(b[1]);
        }
    memset(b, 0, sizeof(b));
}

//-----------------------------------------------------------------------------

void Cipher_Blowfish::doEncode(PVOID source, PVOID dest, int size)
{
    DWORD i, a, b;
    PDWORD p;
    PBLOWFISH d;

    ISE_ASSERT(size == context().blockSize);

    d = (PBLOWFISH)user_;
    p = (PDWORD)((PBYTE)user_ + sizeof(BLOWFISH_DATA));
    a = swapDWord(((PDWORD)source)[0]) ^ p[0];
    p = &p[1];
    b = swapDWord(((PDWORD)source)[1]);

    for (i = 0; i < 8; i++)
    {
        b = b ^ p[0] ^ (
            (((*d)[0][a >> 24] + (*d)[1][a >> 16 & 0xFF]) ^ (*d)[2][a >> 8 & 0xFF]) + (*d)[3][a & 0xFF]);

        a = a ^ p[1] ^ (
            (((*d)[0][b >> 24] + (*d)[1][b >> 16 & 0xFF]) ^ (*d)[2][b >> 8 & 0xFF]) + (*d)[3][b & 0xFF]);

        p = &p[2];
    }

    ((PDWORD)dest)[0] = swapDWord(b ^ p[0]);
    ((PDWORD)dest)[1] = swapDWord(a);
}

//-----------------------------------------------------------------------------

void Cipher_Blowfish::doDecode(PVOID source, PVOID dest, int size)
{
    DWORD i, a, b;
    PDWORD p;
    PBLOWFISH d;

    ISE_ASSERT(size == context().blockSize);

    d = (PBLOWFISH)user_;
    p = (PDWORD)((PBYTE)user_ + sizeof(BLOWFISH_DATA) + sizeof(BLOWFISH_KEY) - sizeof(DWORD));
    a = swapDWord(((PDWORD)source)[0]) ^ p[0];
    b = swapDWord(((PDWORD)source)[1]);

    for (i = 0; i < 8; i++)
    {
        p -= 2;
        b = b ^ p[1] ^ (
            (((*d)[0][a >> 24] + (*d)[1][a >> 16 & 0xFF]) ^ (*d)[2][a >> 8 & 0xFF]) + (*d)[3][a & 0xFF]);

        a = a ^ p[0] ^ (
            (((*d)[0][b >> 24] + (*d)[1][b >> 16 & 0xFF]) ^ (*d)[2][b >> 8 & 0xFF]) + (*d)[3][b & 0xFF]);
    }

    p--;
    ((PDWORD)dest)[0] = swapDWord(b ^ p[0]);
    ((PDWORD)dest)[1] = swapDWord(a);
}

//-----------------------------------------------------------------------------

CipherContext Cipher_Blowfish::context()
{
    CipherContext context;

    context.keySize = 56;
    context.blockSize = 8;
    context.bufferSize = 8;
    context.userSize = sizeof(BLOWFISH_DATA) + sizeof(BLOWFISH_KEY);
    context.userSave = false;

    return context;
}

///////////////////////////////////////////////////////////////////////////////
// Cipher_IDEA

static WORD IDEAInv(WORD x)
{
    WORD a, b, c, d;

    if (x <= 1)
        return x;

    a = 1;
    b = 0x10001 / x;
    c = 0x10001 % x;
    while (c != 1)
    {
        d = x / c;
        x = x % c;
        a += (b * d);
        if (x == 1)
            return a;
        d = c / x;
        c = c % x;
        b += (a * d);
    }

    return (1 - b);
}

//-----------------------------------------------------------------------------

static DWORD IDEAMul(DWORD x, DWORD y)
{
#ifdef ISE_WINDOWS
    DWORD result;

    __asm
    {
        MOV    EAX, x
        MOV    EDX, y
        AND    EAX, 0FFFFh
        JZ     _001
        AND    EDX, 0FFFFh
        JZ     _001
        MUL    EDX
        MOV    EDX, EAX
        MOV    ECX, EAX
        SHR    EDX, 16
        SUB    EAX, EDX
        SUB    CX, AX
        ADC    EAX, 0
        JMP    _002
    _001:
        LEA    EAX, [EAX + EDX -1]
        NEG    EAX
    _002:
        MOV    result, EAX
    }

    return result;
#endif
#ifdef ISE_LINUX
    DWORD result;

    __asm__ __volatile
    (
        "\
        and    $0xFFFF, %%eax; \
        jz     1f; \
        and    $0xFFFF, %%edx; \
        jz     1f; \
        mul    %%edx; \
        mov    %%eax, %%edx; \
        mov    %%eax, %%ecx; \
        shr    $16, %%edx; \
        sub    %%edx, %%eax; \
        sub    %%ax, %%cx; \
        adc    $0, %%eax; \
        jmp    2f; \
    1: \
        add    %%edx, %%eax; \
        dec    %%eax; \
        neg    %%eax; \
    2: \
        nop; \
        "
            : "=a"(result)
            : "a"(x), "d"(y)
    );

    return result;
#endif
}

//-----------------------------------------------------------------------------

static void IDEACipher(PDWORD source, PDWORD dest, PWORD key)
{
    DWORD i, x, y, a, b, c, d;

    i = swapDWord(source[0]);
    a = i >> 16;
    b = i & 0xFFFF;
    i = swapDWord(source[1]);
    c = i >> 16;
    d = i & 0xFFFF;

    for (i = 0; i < 8; i++)
    {
        a = IDEAMul(a, key[0]);
        b += key[1];
        c += key[2];
        d = IDEAMul(d, key[3]);
        y = c ^ a;
        y = IDEAMul(y, key[4]);
        x = (b ^ d) + y;
        x = IDEAMul(x, key[5]);
        y += x;
        a = a ^ x;
        d = d ^ y;
        y = b ^ y;
        b = c ^ x;
        c = y;
        key = &key[6];
    }

    dest[0] = swapDWord( (IDEAMul(a, key[0]) << 16) | ((c + key[1]) & 0xFFFF) );
    dest[1] = swapDWord( ((b + key[2]) << 16) | (IDEAMul(d, key[3]) & 0xFFFF) );
}

//-----------------------------------------------------------------------------

void Cipher_IDEA::doInit(PVOID key, int size)
{
    int i;
    PWORD e, k, d;
    WORD a, b, c;

    e = (PWORD)user_;
    memmove(e, key, size);
    for (i = 0; i < 8; i++)
        e[i] = swapWord(e[i]);
    for (i = 0; i < 40; i++)
    {
        e[i + 8] =
            e[(i & ~7) + ((i+1) & 7)] << 9 |
            e[(i & ~7) + ((i+2) & 7)] >> 7;
    }
    for (i = 41; i < 45; i++)
        e[i + 7] = e[i] << 9 | e[i + 1] >> 7;

    k = e;
    d = &e[100];
    a = IDEAInv(k[0]);
    b = 0 - k[1];
    c = 0 - k[2];
    d[3] = IDEAInv(k[3]);
    d[2] = c;
    d[1] = b;
    d[0] = a;
    k += 4;

    for (i = 1; i <= 8; i++)
    {
        d -= 6;
        a = k[0];
        d[5] = k[1];
        d[4] = a;
        a = IDEAInv(k[2]);
        b = 0 - k[3];
        c = 0 - k[4];
        d[3] = IDEAInv(k[5]);
        d[2] = b;
        d[1] = c;
        d[0] = a;
        k += 6;
    }
    a = d[2];
    d[2] = d[1];
    d[1] = a;
}

//-----------------------------------------------------------------------------

void Cipher_IDEA::doEncode(PVOID source, PVOID dest, int size)
{
    ISE_ASSERT(size == context().blockSize);
    IDEACipher((PDWORD)source, (PDWORD)dest, (PWORD)user_);
}

//-----------------------------------------------------------------------------

void Cipher_IDEA::doDecode(PVOID source, PVOID dest, int size)
{
    ISE_ASSERT(size == context().blockSize);
    IDEACipher((PDWORD)source, (PDWORD)dest, (PWORD)((PDWORD)user_ + 26));
}

//-----------------------------------------------------------------------------

CipherContext Cipher_IDEA::context()
{
    CipherContext context;

    context.keySize = 16;
    context.blockSize = 8;
    context.bufferSize = 8;
    context.userSize = 208;
    context.userSave = false;

    return context;
}

///////////////////////////////////////////////////////////////////////////////
// Cipher_DES

static void DESCipher(PDWORD source, PDWORD dest, PDWORD key)
{
    DWORD l, r, x, y, i;

    l = swapDWord(source[0]);
    r = swapDWord(source[1]);

    x = (l >>  4 ^ r) & 0x0F0F0F0F; r = r ^ x; l = l ^ x <<  4;
    x = (l >> 16 ^ r) & 0x0000FFFF; r = r ^ x; l = l ^ x << 16;
    x = (r >>  2 ^ l) & 0x33333333; l = l ^ x; r = r ^ x <<  2;
    x = (r >>  8 ^ l) & 0x00FF00FF; l = l ^ x; r = r ^ x <<  8;

    r = r << 1 | r >> 31;
    x = (l ^ r) & 0xAAAAAAAA;
    r = r ^ x;
    l = l ^ x;
    l = l << 1 | l >> 31;

    for (i = 0; i < 8; i++)
    {
        x = (r << 28 | r >> 4) ^ key[0];
        y = r ^ key[1];
        l ^= (
            DES_DATA[0][x       & 0x3F] | DES_DATA[1][x >>  8 & 0x3F] |
            DES_DATA[2][x >> 16 & 0x3F] | DES_DATA[3][x >> 24 & 0x3F] |
            DES_DATA[4][y       & 0x3F] | DES_DATA[5][y >>  8 & 0x3F] |
            DES_DATA[6][y >> 16 & 0x3F] | DES_DATA[7][y >> 24 & 0x3F]
            );

        x = (l << 28 | l >> 4) ^ key[2];
        y = l ^ key[3];
        r ^= (
            DES_DATA[0][x       & 0x3F] | DES_DATA[1][x >>  8 & 0x3F] |
            DES_DATA[2][x >> 16 & 0x3F] | DES_DATA[3][x >> 24 & 0x3F] |
            DES_DATA[4][y       & 0x3F] | DES_DATA[5][y >>  8 & 0x3F] |
            DES_DATA[6][y >> 16 & 0x3F] | DES_DATA[7][y >> 24 & 0x3F]
            );
        key = &key[4];
    }

    r = r << 31 | r >> 1;
    x = (l ^ r) & 0xAAAAAAAA;
    r = r ^ x;
    l = l ^ x;
    l = l << 31 | l >> 1;

    x = (l >>  8 ^ r) & 0x00FF00FF; r = r ^ x; l = l ^ x <<  8;
    x = (l >>  2 ^ r) & 0x33333333; r = r ^ x; l = l ^ x <<  2;
    x = (r >> 16 ^ l) & 0x0000FFFF; l = l ^ x; r = r ^ x << 16;
    x = (r >>  4 ^ l) & 0x0F0F0F0F; l = l ^ x; r = r ^ x <<  4;

    dest[0] = swapDWord(r);
    dest[1] = swapDWord(l);
}

//-----------------------------------------------------------------------------

void Cipher_DES::doInit(PVOID key, int size)
{
    BYTE k[8];

    memset(k, 0, sizeof(k));
    memmove(k, key, size);
    DoInitKey(k, (PDWORD)user_, false);
    DoInitKey(k, (PDWORD)user_ + 32, true);
    protectBuffer(k, sizeof(k));
}

//-----------------------------------------------------------------------------

void Cipher_DES::doEncode(PVOID source, PVOID dest, int size)
{
    ISE_ASSERT(size == context().bufferSize);
    DESCipher((PDWORD)source, (PDWORD)dest, (PDWORD)user_);
}

//-----------------------------------------------------------------------------

void Cipher_DES::doDecode(PVOID source, PVOID dest, int size)
{
    ISE_ASSERT(size == context().bufferSize);
    DESCipher((PDWORD)source, (PDWORD)dest, (PDWORD)user_ + 32);
}

//-----------------------------------------------------------------------------

CipherContext Cipher_DES::context()
{
    CipherContext context;

    context.keySize = 8;
    context.blockSize = 8;
    context.bufferSize = 8;
    context.userSize = 32 * 4 * 2;
    context.userSave = false;

    return context;
}

//-----------------------------------------------------------------------------

void Cipher_DES::DoInitKey(PBYTE data, PDWORD key, bool reverse)
{
    const BYTE ROT[16] = {1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28};

    DWORD i, j,l, m, n;
    BYTE pcm[56], pcr[56];
    DWORD k[32];

    memset(k, 0, sizeof(k));
    for (i = 0; i < 56; i++)
    {
        if ((data[DES_PC1[i] >> 3] & (0x80 >> (DES_PC1[i] & 0x07))) != 0)
            pcm[i] = 1;
        else
            pcm[i] = 0;
    }
    for (i = 0; i < 16; i++)
    {
        if (reverse)
            m = (15 - i) << 1;
        else
            m = i << 1;
        n = m + 1;
        for (j = 0; j < 28; j++)
        {
            l = j + ROT[i];
            if (l < 28)
                pcr[j] = pcm[l];
            else
                pcr[j] = pcm[l - 28];
        }
        for (j = 28; j < 56; j++)
        {
            l = j + ROT[i];
            if (l < 56)
                pcr[j] = pcm[l];
            else
                pcr[j] = pcm[l - 28];
        }
        l = 0x1000000;
        for (j = 0; j < 24; j++)
        {
            l = l >> 1;
            if (pcr[DES_PC2[j]] != 0)
                k[m] |= l;
            if (pcr[DES_PC2[j+24]] != 0)
                k[n] |= l;
        }
    }
    for (i = 0; i < 16; i++)
    {
        m = i << 1;
        n = m + 1;
        key[0] =
            (k[m] & 0x00FC0000) <<  6 |
            (k[m] & 0x00000FC0) << 10 |
            (k[n] & 0x00FC0000) >> 10 |
            (k[n] & 0x00000FC0) >>  6;
        key[1] =
            (k[m] & 0x0003F000) << 12 |
            (k[m] & 0x0000003F) << 16 |
            (k[n] & 0x0003F000) >>  4 |
            (k[n] & 0x0000003F);
        key = &key[2];
    }

    protectBuffer(k, sizeof(k));
    protectBuffer(pcm, sizeof(pcm));
    protectBuffer(pcr, sizeof(pcr));
}

///////////////////////////////////////////////////////////////////////////////
// Cipher_Gost

void Cipher_Gost::doInit(PVOID key, int size)
{
    memmove(user_, key, size);
}

//-----------------------------------------------------------------------------

void Cipher_Gost::doEncode(PVOID source, PVOID dest, int size)
{
    ISE_ASSERT(size == context().bufferSize);

    DWORD i, a, b, t;
    PDWORD k;

    k = (PDWORD)user_;
    a = ((PDWORD)source)[0];
    b = ((PDWORD)source)[1];

    for (i = 0; i < 12; i++)
    {
        if ((i & 3) == 0) k = (PDWORD)user_;

        t = a + k[0];
        b ^=
            GOST_DATA[0][t       & 0xFF] ^
            GOST_DATA[1][t >>  8 & 0xFF] ^
            GOST_DATA[2][t >> 16 & 0xFF] ^
            GOST_DATA[3][t >> 24       ];
        t = b + k[1];
        a ^=
            GOST_DATA[0][t       & 0xFF] ^
            GOST_DATA[1][t >>  8 & 0xFF] ^
            GOST_DATA[2][t >> 16 & 0xFF] ^
            GOST_DATA[3][t >> 24       ];
        k = &k[2];
    }

    k = (PDWORD)user_ + 6;
    for (i = 0; i < 4; i++)
    {
        t = a + k[1];
        b ^=
            GOST_DATA[0][t       & 0xFF] ^
            GOST_DATA[1][t >>  8 & 0xFF] ^
            GOST_DATA[2][t >> 16 & 0xFF] ^
            GOST_DATA[3][t >> 24       ];
        t = b + k[0];
        a ^=
            GOST_DATA[0][t       & 0xFF] ^
            GOST_DATA[1][t >>  8 & 0xFF] ^
            GOST_DATA[2][t >> 16 & 0xFF] ^
            GOST_DATA[3][t >> 24       ];
        k -= 2;
    }

    ((PDWORD)dest)[0] = b;
    ((PDWORD)dest)[1] = a;
}

//-----------------------------------------------------------------------------

void Cipher_Gost::doDecode(PVOID source, PVOID dest, int size)
{
    ISE_ASSERT(size == context().bufferSize);

    DWORD i, a, b, t;
    PDWORD k;

    a = ((PDWORD)source)[0];
    b = ((PDWORD)source)[1];
    k = (PDWORD)user_;

    for (i = 0; i < 4; i++)
    {
        t = a + k[0];
        b ^=
            GOST_DATA[0][t & 0xFF] ^
            GOST_DATA[1][t >>  8 & 0xFF] ^
            GOST_DATA[2][t >> 16 & 0xFF] ^
            GOST_DATA[3][t >> 24];
        t = b + k[1];
        a ^=
            GOST_DATA[0][t & 0xFF] ^
            GOST_DATA[1][t >>  8 & 0xFF] ^
            GOST_DATA[2][t >> 16 & 0xFF] ^
            GOST_DATA[3][t >> 24];
        k = &k[2];
    }
    for (i = 0; i < 12; i++)
    {
        if ((i & 3) == 0)
            k = (PDWORD)user_ + 6;

        t = a + k[1];
        b ^=
            GOST_DATA[0][t & 0xFF] ^
            GOST_DATA[1][t >>  8 & 0xFF] ^
            GOST_DATA[2][t >> 16 & 0xFF] ^
            GOST_DATA[3][t >> 24];
        t = b + k[0];
        a ^=
            GOST_DATA[0][t & 0xFF] ^
            GOST_DATA[1][t >>  8 & 0xFF] ^
            GOST_DATA[2][t >> 16 & 0xFF] ^
            GOST_DATA[3][t >> 24];
        k -= 2;
    }

    ((PDWORD)dest)[0] = b;
    ((PDWORD)dest)[1] = a;
}

//-----------------------------------------------------------------------------

CipherContext Cipher_Gost::context()
{
    CipherContext context;

    context.keySize = 32;
    context.blockSize = 8;
    context.bufferSize = 8;
    context.userSize = 32;
    context.userSave = false;

    return context;
}

///////////////////////////////////////////////////////////////////////////////

} // namespace utils

} // namespace ise
